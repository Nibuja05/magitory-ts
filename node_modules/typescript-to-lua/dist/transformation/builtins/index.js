"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformBuiltinIdentifierExpression = exports.transformBuiltinCallExpression = exports.transformBuiltinPropertyAccessExpression = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const utils_1 = require("../../utils");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const symbols_1 = require("../utils/symbols");
const typescript_1 = require("../utils/typescript");
const new_1 = require("../visitors/class/new");
const array_1 = require("./array");
const console_1 = require("./console");
const function_1 = require("./function");
const global_1 = require("./global");
const math_1 = require("./math");
const number_1 = require("./number");
const object_1 = require("./object");
const string_1 = require("./string");
const symbol_1 = require("./symbol");
function transformBuiltinPropertyAccessExpression(context, node) {
    const ownerType = context.checker.getTypeAtLocation(node.expression);
    if (typescript_1.isStringType(context, ownerType)) {
        return string_1.transformStringProperty(context, node);
    }
    if (typescript_1.isArrayType(context, ownerType)) {
        return array_1.transformArrayProperty(context, node);
    }
    if (typescript_1.isFunctionType(context, ownerType)) {
        return function_1.transformFunctionProperty(context, node);
    }
    if (ts.isIdentifier(node.expression) && typescript_1.isStandardLibraryType(context, ownerType, undefined)) {
        switch (node.expression.text) {
            case "Math":
                return math_1.transformMathProperty(context, node);
            case "Symbol":
                lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.Symbol);
        }
    }
}
exports.transformBuiltinPropertyAccessExpression = transformBuiltinPropertyAccessExpression;
function transformBuiltinCallExpression(context, node) {
    const expressionType = context.checker.getTypeAtLocation(node.expression);
    if (ts.isIdentifier(node.expression) && typescript_1.isStandardLibraryType(context, expressionType, undefined)) {
        // TODO:
        new_1.checkForLuaLibType(context, expressionType);
        const result = global_1.transformGlobalCall(context, node);
        if (result) {
            return result;
        }
    }
    if (!ts.isPropertyAccessExpression(node.expression)) {
        return;
    }
    utils_1.assume(node);
    // If the function being called is of type owner.func, get the type of owner
    const ownerType = context.checker.getTypeAtLocation(node.expression.expression);
    if (typescript_1.isStandardLibraryType(context, ownerType, undefined)) {
        const symbol = ownerType.getSymbol();
        switch (symbol === null || symbol === void 0 ? void 0 : symbol.name) {
            case "Console":
                return console_1.transformConsoleCall(context, node);
            case "Math":
                return math_1.transformMathCall(context, node);
            case "StringConstructor":
                return string_1.transformStringConstructorCall(context, node);
            case "ObjectConstructor":
                return object_1.transformObjectConstructorCall(context, node);
            case "SymbolConstructor":
                return symbol_1.transformSymbolConstructorCall(context, node);
            case "NumberConstructor":
                return number_1.transformNumberConstructorCall(context, node);
        }
    }
    if (typescript_1.isStringType(context, ownerType) && typescript_1.hasStandardLibrarySignature(context, node)) {
        return string_1.transformStringPrototypeCall(context, node);
    }
    if (typescript_1.isNumberType(context, ownerType) && typescript_1.hasStandardLibrarySignature(context, node)) {
        return number_1.transformNumberPrototypeCall(context, node);
    }
    if (typescript_1.isArrayType(context, ownerType) && typescript_1.hasStandardLibrarySignature(context, node)) {
        return array_1.transformArrayPrototypeCall(context, node);
    }
    if (typescript_1.isFunctionType(context, ownerType) && typescript_1.hasStandardLibrarySignature(context, node)) {
        return function_1.transformFunctionPrototypeCall(context, node);
    }
    const objectResult = object_1.transformObjectPrototypeCall(context, node);
    if (objectResult) {
        return objectResult;
    }
}
exports.transformBuiltinCallExpression = transformBuiltinCallExpression;
function transformBuiltinIdentifierExpression(context, node) {
    switch (node.text) {
        case "NaN":
            return lua_ast_1.createNaN(node);
        case "Infinity":
            const math = lua.createIdentifier("math");
            const huge = lua.createStringLiteral("huge");
            return lua.createTableIndexExpression(math, huge, node);
        case "globalThis":
            return lua.createIdentifier("_G", node, symbols_1.getIdentifierSymbolId(context, node), "globalThis");
    }
}
exports.transformBuiltinIdentifierExpression = transformBuiltinIdentifierExpression;
//# sourceMappingURL=index.js.map