"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performHoisting = exports.popScope = exports.pushScope = exports.findScope = exports.peekScope = exports.markSymbolAsReferencedInCurrentScopes = exports.walkScopesUp = exports.ScopeType = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const utils_1 = require("../../utils");
const symbols_1 = require("./symbols");
const typescript_1 = require("./typescript");
var ScopeType;
(function (ScopeType) {
    ScopeType[ScopeType["File"] = 1] = "File";
    ScopeType[ScopeType["Function"] = 2] = "Function";
    ScopeType[ScopeType["Switch"] = 4] = "Switch";
    ScopeType[ScopeType["Loop"] = 8] = "Loop";
    ScopeType[ScopeType["Conditional"] = 16] = "Conditional";
    ScopeType[ScopeType["Block"] = 32] = "Block";
    ScopeType[ScopeType["Try"] = 64] = "Try";
    ScopeType[ScopeType["Catch"] = 128] = "Catch";
})(ScopeType = exports.ScopeType || (exports.ScopeType = {}));
const scopeStacks = new WeakMap();
function getScopeStack(context) {
    return utils_1.getOrUpdate(scopeStacks, context, () => []);
}
function* walkScopesUp(context) {
    const scopeStack = getScopeStack(context);
    for (let i = scopeStack.length - 1; i >= 0; --i) {
        const scope = scopeStack[i];
        yield scope;
    }
}
exports.walkScopesUp = walkScopesUp;
function markSymbolAsReferencedInCurrentScopes(context, symbolId, identifier) {
    for (const scope of getScopeStack(context)) {
        if (!scope.referencedSymbols) {
            scope.referencedSymbols = new Map();
        }
        const references = utils_1.getOrUpdate(scope.referencedSymbols, symbolId, () => []);
        references.push(identifier);
    }
}
exports.markSymbolAsReferencedInCurrentScopes = markSymbolAsReferencedInCurrentScopes;
function peekScope(context) {
    const scopeStack = getScopeStack(context);
    const scope = scopeStack[scopeStack.length - 1];
    utils_1.assert(scope);
    return scope;
}
exports.peekScope = peekScope;
function findScope(context, scopeTypes) {
    return [...getScopeStack(context)].reverse().find(s => scopeTypes & s.type);
}
exports.findScope = findScope;
const scopeIdCounters = new WeakMap();
function pushScope(context, scopeType) {
    var _a;
    const nextScopeId = ((_a = scopeIdCounters.get(context)) !== null && _a !== void 0 ? _a : 0) + 1;
    scopeIdCounters.set(context, nextScopeId);
    const scopeStack = getScopeStack(context);
    const scope = { type: scopeType, id: nextScopeId };
    scopeStack.push(scope);
    return scope;
}
exports.pushScope = pushScope;
function popScope(context) {
    const scopeStack = getScopeStack(context);
    const scope = scopeStack.pop();
    utils_1.assert(scope);
    return scope;
}
exports.popScope = popScope;
function performHoisting(context, statements) {
    const scope = peekScope(context);
    let result = statements;
    result = hoistFunctionDefinitions(context, scope, result);
    result = hoistVariableDeclarations(context, scope, result);
    result = hoistImportStatements(scope, result);
    return result;
}
exports.performHoisting = performHoisting;
function shouldHoistSymbol(context, symbolId, scope) {
    const symbolInfo = symbols_1.getSymbolInfo(context, symbolId);
    if (!symbolInfo) {
        return false;
    }
    const declaration = typescript_1.getFirstDeclarationInFile(symbolInfo.symbol, context.sourceFile);
    if (!declaration) {
        return false;
    }
    if (symbolInfo.firstSeenAtPos < declaration.pos) {
        return true;
    }
    if (scope.functionDefinitions) {
        for (const [functionSymbolId, functionDefinition] of scope.functionDefinitions) {
            utils_1.assert(functionDefinition.definition);
            const { line, column } = lua.getOriginalPos(functionDefinition.definition);
            if (line !== undefined && column !== undefined) {
                const definitionPos = ts.getPositionOfLineAndCharacter(context.sourceFile, line, column);
                if (functionSymbolId !== symbolId && // Don't recurse into self
                    declaration.pos < definitionPos && // Ignore functions before symbol declaration
                    functionDefinition.referencedSymbols.has(symbolId) &&
                    shouldHoistSymbol(context, functionSymbolId, scope)) {
                    return true;
                }
            }
        }
    }
    return false;
}
function hoistVariableDeclarations(context, scope, statements) {
    if (!scope.variableDeclarations) {
        return statements;
    }
    const result = [...statements];
    const hoistedLocals = [];
    for (const declaration of scope.variableDeclarations) {
        const symbols = declaration.left.map(i => i.symbolId).filter(utils_1.isNonNull);
        if (symbols.some(s => shouldHoistSymbol(context, s, scope))) {
            const index = result.indexOf(declaration);
            utils_1.assert(index > -1);
            if (declaration.right) {
                const assignment = lua.createAssignmentStatement(declaration.left, declaration.right);
                lua.setNodePosition(assignment, declaration); // Preserve position info for sourcemap
                result.splice(index, 1, assignment);
            }
            else {
                result.splice(index, 1);
            }
            hoistedLocals.push(...declaration.left);
        }
        else if (scope.type === ScopeType.Switch) {
            utils_1.assert(!declaration.right);
            hoistedLocals.push(...declaration.left);
        }
    }
    if (hoistedLocals.length > 0) {
        result.unshift(lua.createVariableDeclarationStatement(hoistedLocals));
    }
    return result;
}
function hoistFunctionDefinitions(context, scope, statements) {
    if (!scope.functionDefinitions) {
        return statements;
    }
    const result = [...statements];
    const hoistedFunctions = [];
    for (const [functionSymbolId, functionDefinition] of scope.functionDefinitions) {
        utils_1.assert(functionDefinition.definition);
        if (shouldHoistSymbol(context, functionSymbolId, scope)) {
            const index = result.indexOf(functionDefinition.definition);
            result.splice(index, 1);
            hoistedFunctions.push(functionDefinition.definition);
        }
    }
    return [...hoistedFunctions, ...result];
}
function hoistImportStatements(scope, statements) {
    return scope.importStatements ? [...scope.importStatements, ...statements] : statements;
}
//# sourceMappingURL=scope.js.map