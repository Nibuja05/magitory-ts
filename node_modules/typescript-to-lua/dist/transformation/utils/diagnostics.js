"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.annotationDeprecated = exports.unsupportedMultiFunctionAssignment = exports.invalidMultiReturnAccess = exports.invalidMultiTypeArrayLiteralElementInitializer = exports.invalidMultiTypeArrayBindingPatternElementInitializer = exports.invalidMultiTypeToEmptyPatternOrArrayLiteral = exports.invalidMultiTypeToNonArrayLiteral = exports.invalidMultiTypeToNonArrayBindingPattern = exports.invalidMultiFunctionUse = exports.unsupportedVarDeclaration = exports.unresolvableRequirePath = exports.invalidAmbientIdentifierName = exports.unsupportedProperty = exports.unsupportedForTarget = exports.unsupportedRightShiftOperator = exports.unsupportedAccessorInObjectLiteral = exports.luaIteratorForbiddenUsage = exports.luaTableForbiddenUsage = exports.luaTableCannotBeAccessedDynamically = exports.luaTableInvalidInstanceOf = exports.luaTableCannotBeExtended = exports.luaTableMustBeAmbient = exports.invalidForRangeCall = exports.metaExtensionMissingExtends = exports.extensionAndMetaExtensionConflict = exports.extensionInvalidInstanceOf = exports.extensionCannotExport = exports.extensionCannotExtend = exports.extensionCannotConstruct = exports.annotationInvalidArgumentCount = exports.decoratorInvalidContext = exports.unsupportedOverloadAssignment = exports.unsupportedSelfFunctionConversion = exports.unsupportedNoSelfFunctionConversion = exports.forbiddenForIn = exports.unsupportedNodeKind = void 0;
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
const utils_1 = require("../../utils");
const createDiagnosticFactory = (category, message) => utils_1.createSerialDiagnosticFactory((node, ...args) => ({
    file: node.getSourceFile(),
    start: node.getStart(),
    length: node.getWidth(),
    messageText: typeof message === "string" ? message : message(...args),
    category,
}));
const createErrorDiagnosticFactory = (message) => createDiagnosticFactory(ts.DiagnosticCategory.Error, message);
const createWarningDiagnosticFactory = (message) => createDiagnosticFactory(ts.DiagnosticCategory.Warning, message);
exports.unsupportedNodeKind = createErrorDiagnosticFactory((kind) => `Unsupported node kind ${ts.SyntaxKind[kind]}`);
exports.forbiddenForIn = createErrorDiagnosticFactory("Iterating over arrays with 'for ... in' is not allowed.");
exports.unsupportedNoSelfFunctionConversion = createErrorDiagnosticFactory((name) => {
    const nameReference = name ? ` '${name}'` : "";
    return (`Unable to convert function with a 'this' parameter to function${nameReference} with no 'this'. ` +
        "To fix, wrap in an arrow function, or declare with 'this: void'.");
});
exports.unsupportedSelfFunctionConversion = createErrorDiagnosticFactory((name) => {
    const nameReference = name ? ` '${name}'` : "";
    return (`Unable to convert function with no 'this' parameter to function${nameReference} with 'this'. ` +
        "To fix, wrap in an arrow function, or declare with 'this: any'.");
});
exports.unsupportedOverloadAssignment = createErrorDiagnosticFactory((name) => {
    const nameReference = name ? ` to '${name}'` : "";
    return (`Unsupported assignment of function with different overloaded types for 'this'${nameReference}. ` +
        "Overloads should all have the same type for 'this'.");
});
exports.decoratorInvalidContext = createErrorDiagnosticFactory("Decorator function cannot have 'this: void'.");
exports.annotationInvalidArgumentCount = createErrorDiagnosticFactory((kind, got, expected) => `'@${kind}' expects ${expected} arguments, but got ${got}.`);
exports.extensionCannotConstruct = createErrorDiagnosticFactory("Cannot construct classes with '@extension' or '@metaExtension' annotation.");
exports.extensionCannotExtend = createErrorDiagnosticFactory("Cannot extend classes with '@extension' or '@metaExtension' annotation.");
exports.extensionCannotExport = createErrorDiagnosticFactory("Cannot export classes with '@extension' or '@metaExtension' annotation.");
exports.extensionInvalidInstanceOf = createErrorDiagnosticFactory("Cannot use instanceof on classes with '@extension' or '@metaExtension' annotation.");
exports.extensionAndMetaExtensionConflict = createErrorDiagnosticFactory("Cannot use both '@extension' and '@metaExtension' annotations on the same class.");
exports.metaExtensionMissingExtends = createErrorDiagnosticFactory("'@metaExtension' annotation requires the extension of the metatable class.");
exports.invalidForRangeCall = createErrorDiagnosticFactory((message) => `Invalid @forRange call: ${message}.`);
exports.luaTableMustBeAmbient = createErrorDiagnosticFactory("Classes with the '@luaTable' annotation must be ambient.");
exports.luaTableCannotBeExtended = createErrorDiagnosticFactory("Cannot extend classes with the '@luaTable' annotation.");
exports.luaTableInvalidInstanceOf = createErrorDiagnosticFactory("The instanceof operator cannot be used with a '@luaTable' class.");
exports.luaTableCannotBeAccessedDynamically = createErrorDiagnosticFactory("@luaTable cannot be accessed dynamically.");
exports.luaTableForbiddenUsage = createErrorDiagnosticFactory((description) => `Invalid @luaTable usage: ${description}.`);
exports.luaIteratorForbiddenUsage = createErrorDiagnosticFactory("Unsupported use of lua iterator with '@tupleReturn' annotation in for...of statement. " +
    "You must use a destructuring statement to catch results from a lua iterator with " +
    "the '@tupleReturn' annotation.");
exports.unsupportedAccessorInObjectLiteral = createErrorDiagnosticFactory("Accessors in object literal are not supported.");
exports.unsupportedRightShiftOperator = createErrorDiagnosticFactory("Right shift operator is not supported for target Lua 5.3. Use `>>>` instead.");
const getLuaTargetName = (version) => (version === CompilerOptions_1.LuaTarget.LuaJIT ? "LuaJIT" : `Lua ${version}`);
exports.unsupportedForTarget = createErrorDiagnosticFactory((functionality, version) => `${functionality} is/are not supported for target ${getLuaTargetName(version)}.`);
exports.unsupportedProperty = createErrorDiagnosticFactory((parentName, property) => `${parentName}.${property} is unsupported.`);
exports.invalidAmbientIdentifierName = createErrorDiagnosticFactory((text) => `Invalid ambient identifier name '${text}'. Ambient identifiers must be valid lua identifiers.`);
exports.unresolvableRequirePath = createErrorDiagnosticFactory((path) => `Cannot create require path. Module '${path}' does not exist within --rootDir.`);
exports.unsupportedVarDeclaration = createErrorDiagnosticFactory("`var` declarations are not supported. Use `let` or `const` instead.");
exports.invalidMultiFunctionUse = createErrorDiagnosticFactory("The $multi function must be called in an expression that is returned.");
exports.invalidMultiTypeToNonArrayBindingPattern = createErrorDiagnosticFactory("Expected an array destructuring pattern.");
exports.invalidMultiTypeToNonArrayLiteral = createErrorDiagnosticFactory("Expected an array literal.");
exports.invalidMultiTypeToEmptyPatternOrArrayLiteral = createErrorDiagnosticFactory("There must be one or more elements specified here.");
exports.invalidMultiTypeArrayBindingPatternElementInitializer = createErrorDiagnosticFactory("This array binding pattern cannot have initializers.");
exports.invalidMultiTypeArrayLiteralElementInitializer = createErrorDiagnosticFactory("This array literal pattern cannot have initializers.");
exports.invalidMultiReturnAccess = createErrorDiagnosticFactory("The MultiReturn type can only be accessed via an element access expression of a numeric type.");
exports.unsupportedMultiFunctionAssignment = createErrorDiagnosticFactory("Omitted expressions and BindingElements are expected here.");
exports.annotationDeprecated = createWarningDiagnosticFactory((kind) => `'@${kind}' is deprecated and will be removed in a future update. Please update your code before upgrading to the next release, otherwise your project will no longer compile. ` +
    `See https://typescripttolua.github.io/docs/advanced/compiler-annotations#${kind.toLowerCase()} for more information.`);
//# sourceMappingURL=diagnostics.js.map