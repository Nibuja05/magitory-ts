"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isForRangeType = exports.isVarargType = exports.isLuaIteratorType = exports.isInTupleReturnFunction = exports.isTupleReturnCall = exports.getSignatureAnnotations = exports.getFileAnnotations = exports.getNodeAnnotations = exports.getTypeAnnotations = exports.getSymbolAnnotations = exports.AnnotationKind = void 0;
const ts = require("typescript");
const typescript_1 = require("./typescript");
var AnnotationKind;
(function (AnnotationKind) {
    AnnotationKind["Extension"] = "extension";
    AnnotationKind["MetaExtension"] = "metaExtension";
    AnnotationKind["CustomConstructor"] = "customConstructor";
    AnnotationKind["CompileMembersOnly"] = "compileMembersOnly";
    AnnotationKind["NoResolution"] = "noResolution";
    AnnotationKind["PureAbstract"] = "pureAbstract";
    AnnotationKind["Phantom"] = "phantom";
    AnnotationKind["TupleReturn"] = "tupleReturn";
    AnnotationKind["LuaIterator"] = "luaIterator";
    AnnotationKind["LuaTable"] = "luaTable";
    AnnotationKind["NoSelf"] = "noSelf";
    AnnotationKind["NoSelfInFile"] = "noSelfInFile";
    AnnotationKind["Vararg"] = "vararg";
    AnnotationKind["ForRange"] = "forRange";
})(AnnotationKind = exports.AnnotationKind || (exports.AnnotationKind = {}));
function createAnnotation(name, args) {
    const kind = Object.values(AnnotationKind).find(k => k.toLowerCase() === name.toLowerCase());
    if (kind !== undefined) {
        return { kind, args };
    }
}
function collectAnnotations(source, annotationsMap) {
    for (const tag of source.getJsDocTags()) {
        const annotation = createAnnotation(tag.name, tag.text ? tag.text.split(" ") : []);
        if (annotation) {
            annotationsMap.set(annotation.kind, annotation);
        }
    }
}
function getSymbolAnnotations(symbol) {
    const annotationsMap = new Map();
    collectAnnotations(symbol, annotationsMap);
    return annotationsMap;
}
exports.getSymbolAnnotations = getSymbolAnnotations;
function getTypeAnnotations(type) {
    const annotationsMap = new Map();
    if (type.symbol)
        collectAnnotations(type.symbol, annotationsMap);
    if (type.aliasSymbol)
        collectAnnotations(type.aliasSymbol, annotationsMap);
    return annotationsMap;
}
exports.getTypeAnnotations = getTypeAnnotations;
function getNodeAnnotations(node) {
    const annotationsMap = new Map();
    for (const tag of ts.getJSDocTags(node)) {
        const tagName = tag.tagName.text;
        const annotation = createAnnotation(tagName, tag.comment ? tag.comment.split(" ") : []);
        if (annotation) {
            annotationsMap.set(annotation.kind, annotation);
        }
    }
    return annotationsMap;
}
exports.getNodeAnnotations = getNodeAnnotations;
function getFileAnnotations(sourceFile) {
    const annotationsMap = new Map();
    if (sourceFile.statements.length > 0) {
        // Manually collect jsDoc because `getJSDocTags` includes tags only from closest comment
        const jsDoc = sourceFile.statements[0].jsDoc;
        if (jsDoc) {
            for (const tag of jsDoc.flatMap(x => { var _a; return (_a = x.tags) !== null && _a !== void 0 ? _a : []; })) {
                const tagName = tag.tagName.text;
                const annotation = createAnnotation(tagName, tag.comment ? tag.comment.split(" ") : []);
                if (annotation) {
                    annotationsMap.set(annotation.kind, annotation);
                }
            }
        }
    }
    return annotationsMap;
}
exports.getFileAnnotations = getFileAnnotations;
function getSignatureAnnotations(context, signature) {
    const annotationsMap = new Map();
    collectAnnotations(signature, annotationsMap);
    // Function properties on interfaces have the JSDoc tags on the parent PropertySignature
    const declaration = signature.getDeclaration();
    if ((declaration === null || declaration === void 0 ? void 0 : declaration.parent) && ts.isPropertySignature(declaration.parent)) {
        const symbol = context.checker.getSymbolAtLocation(declaration.parent.name);
        if (symbol) {
            collectAnnotations(symbol, annotationsMap);
        }
    }
    return annotationsMap;
}
exports.getSignatureAnnotations = getSignatureAnnotations;
function isTupleReturnCall(context, node) {
    if (!ts.isCallExpression(node)) {
        return false;
    }
    const signature = context.checker.getResolvedSignature(node);
    if (signature) {
        if (getSignatureAnnotations(context, signature).has(AnnotationKind.TupleReturn)) {
            return true;
        }
        // Only check function type for directive if it is declared as an interface or type alias
        const declaration = signature.getDeclaration();
        const isInterfaceOrAlias = (declaration === null || declaration === void 0 ? void 0 : declaration.parent) &&
            ((ts.isInterfaceDeclaration(declaration.parent) && ts.isCallSignatureDeclaration(declaration)) ||
                ts.isTypeAliasDeclaration(declaration.parent));
        if (!isInterfaceOrAlias) {
            return false;
        }
    }
    const type = context.checker.getTypeAtLocation(node.expression);
    return getTypeAnnotations(type).has(AnnotationKind.TupleReturn);
}
exports.isTupleReturnCall = isTupleReturnCall;
function isInTupleReturnFunction(context, node) {
    const declaration = typescript_1.findFirstNodeAbove(node, ts.isFunctionLike);
    if (!declaration) {
        return false;
    }
    let functionType;
    if (ts.isFunctionExpression(declaration) || ts.isArrowFunction(declaration)) {
        functionType = typescript_1.inferAssignedType(context, declaration);
    }
    else if (ts.isMethodDeclaration(declaration) && ts.isObjectLiteralExpression(declaration.parent)) {
        // Manually lookup type for object literal properties declared with method syntax
        const interfaceType = typescript_1.inferAssignedType(context, declaration.parent);
        const propertySymbol = interfaceType.getProperty(declaration.name.getText());
        if (propertySymbol) {
            functionType = context.checker.getTypeOfSymbolAtLocation(propertySymbol, declaration);
        }
    }
    if (functionType === undefined) {
        functionType = context.checker.getTypeAtLocation(declaration);
    }
    // Check all overloads for directive
    const signatures = functionType.getCallSignatures();
    if (signatures === null || signatures === void 0 ? void 0 : signatures.some(s => getSignatureAnnotations(context, s).has(AnnotationKind.TupleReturn))) {
        return true;
    }
    return getTypeAnnotations(functionType).has(AnnotationKind.TupleReturn);
}
exports.isInTupleReturnFunction = isInTupleReturnFunction;
function isLuaIteratorType(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return getTypeAnnotations(type).has(AnnotationKind.LuaIterator);
}
exports.isLuaIteratorType = isLuaIteratorType;
function isVarargType(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return getTypeAnnotations(type).has(AnnotationKind.Vararg);
}
exports.isVarargType = isVarargType;
function isForRangeType(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return getTypeAnnotations(type).has(AnnotationKind.ForRange);
}
exports.isForRangeType = isForRangeType;
//# sourceMappingURL=annotations.js.map