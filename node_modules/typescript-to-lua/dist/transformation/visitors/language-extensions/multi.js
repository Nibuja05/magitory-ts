"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMultiAssignmentViolations = exports.transformMultiDestructuringAssignmentStatement = exports.transformMultiVariableDeclaration = exports.transformMultiReturnStatement = exports.transformMultiCallExpressionToReturnStatement = exports.isMultiFunctionNode = exports.returnsMultiType = exports.isMultiFunction = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const extensions = require("../../utils/language-extensions");
const assignments_1 = require("../binary-expression/assignments");
const identifier_1 = require("../identifier");
const call_1 = require("../call");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const diagnostics_1 = require("../../utils/diagnostics");
const utils_1 = require("../../../utils");
const isMultiFunctionDeclaration = (declaration) => extensions.getExtensionKind(declaration) === extensions.ExtensionKind.MultiFunction;
const isMultiTypeDeclaration = (declaration) => extensions.getExtensionKind(declaration) === extensions.ExtensionKind.MultiType;
function isMultiFunction(context, expression) {
    var _a, _b, _c;
    const type = context.checker.getTypeAtLocation(expression.expression);
    return (_c = (_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b.some(isMultiFunctionDeclaration)) !== null && _c !== void 0 ? _c : false;
}
exports.isMultiFunction = isMultiFunction;
function returnsMultiType(context, node) {
    var _a, _b, _c;
    const signature = context.checker.getResolvedSignature(node);
    return (_c = (_b = (_a = signature === null || signature === void 0 ? void 0 : signature.getReturnType().aliasSymbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b.some(isMultiTypeDeclaration)) !== null && _c !== void 0 ? _c : false;
}
exports.returnsMultiType = returnsMultiType;
function isMultiFunctionNode(context, node) {
    var _a, _b, _c;
    const type = context.checker.getTypeAtLocation(node);
    return (_c = (_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b.some(isMultiFunctionDeclaration)) !== null && _c !== void 0 ? _c : false;
}
exports.isMultiFunctionNode = isMultiFunctionNode;
function transformMultiCallExpressionToReturnStatement(context, expression) {
    utils_1.assert(ts.isCallExpression(expression));
    const expressions = call_1.transformArguments(context, expression.arguments);
    return lua.createReturnStatement(expressions, expression);
}
exports.transformMultiCallExpressionToReturnStatement = transformMultiCallExpressionToReturnStatement;
function transformMultiReturnStatement(context, statement) {
    utils_1.assert(statement.expression);
    return transformMultiCallExpressionToReturnStatement(context, statement.expression);
}
exports.transformMultiReturnStatement = transformMultiReturnStatement;
function transformMultiFunctionArguments(context, expression) {
    if (!isMultiFunction(context, expression)) {
        return context.transformExpression(expression);
    }
    if (expression.arguments.length === 0) {
        return lua.createNilLiteral(expression);
    }
    return expression.arguments.map(e => context.transformExpression(e));
}
function transformMultiVariableDeclaration(context, declaration) {
    utils_1.assert(declaration.initializer);
    utils_1.assert(ts.isCallExpression(declaration.initializer));
    if (!ts.isArrayBindingPattern(declaration.name)) {
        context.diagnostics.push(diagnostics_1.invalidMultiTypeToNonArrayBindingPattern(declaration.name));
        return [];
    }
    if (declaration.name.elements.length < 1) {
        context.diagnostics.push(diagnostics_1.invalidMultiTypeToEmptyPatternOrArrayLiteral(declaration.name));
        return [];
    }
    if (declaration.name.elements.some(e => ts.isBindingElement(e) && e.initializer)) {
        context.diagnostics.push(diagnostics_1.invalidMultiTypeArrayBindingPatternElementInitializer(declaration.name));
        return [];
    }
    if (isMultiFunction(context, declaration.initializer)) {
        context.diagnostics.push(diagnostics_1.invalidMultiFunctionUse(declaration.initializer));
        return [];
    }
    const leftIdentifiers = [];
    for (const element of declaration.name.elements) {
        if (ts.isBindingElement(element)) {
            if (ts.isIdentifier(element.name)) {
                leftIdentifiers.push(identifier_1.transformIdentifier(context, element.name));
            }
            else {
                context.diagnostics.push(diagnostics_1.unsupportedMultiFunctionAssignment(element));
            }
        }
        else if (ts.isOmittedExpression(element)) {
            leftIdentifiers.push(lua.createAnonymousIdentifier(element));
        }
    }
    const rightExpressions = transformMultiFunctionArguments(context, declaration.initializer);
    return lua_ast_1.createLocalOrExportedOrGlobalDeclaration(context, leftIdentifiers, rightExpressions, declaration);
}
exports.transformMultiVariableDeclaration = transformMultiVariableDeclaration;
function transformMultiDestructuringAssignmentStatement(context, statement) {
    utils_1.assert(ts.isBinaryExpression(statement.expression));
    utils_1.assert(ts.isCallExpression(statement.expression.right));
    if (!ts.isArrayLiteralExpression(statement.expression.left)) {
        context.diagnostics.push(diagnostics_1.invalidMultiTypeToNonArrayLiteral(statement.expression.left));
        return [];
    }
    if (statement.expression.left.elements.some(ts.isBinaryExpression)) {
        context.diagnostics.push(diagnostics_1.invalidMultiTypeArrayLiteralElementInitializer(statement.expression.left));
        return [];
    }
    if (statement.expression.left.elements.length < 1) {
        context.diagnostics.push(diagnostics_1.invalidMultiTypeToEmptyPatternOrArrayLiteral(statement.expression.left));
        return [];
    }
    if (isMultiFunction(context, statement.expression.right)) {
        context.diagnostics.push(diagnostics_1.invalidMultiFunctionUse(statement.expression.right));
        return [];
    }
    const transformLeft = (expression) => ts.isOmittedExpression(expression)
        ? lua.createAnonymousIdentifier(expression)
        : assignments_1.transformAssignmentLeftHandSideExpression(context, expression);
    const leftIdentifiers = statement.expression.left.elements.map(transformLeft);
    const rightExpressions = transformMultiFunctionArguments(context, statement.expression.right);
    const trailingStatements = statement.expression.left.elements.flatMap(expression => {
        const symbol = context.checker.getSymbolAtLocation(expression);
        const dependentSymbols = symbol ? export_1.getDependenciesOfSymbol(context, symbol) : [];
        return dependentSymbols.map(symbol => {
            const identifierToAssign = export_1.createExportedIdentifier(context, lua.createIdentifier(symbol.name));
            return lua.createAssignmentStatement(identifierToAssign, transformLeft(expression));
        });
    });
    return [lua.createAssignmentStatement(leftIdentifiers, rightExpressions, statement), ...trailingStatements];
}
exports.transformMultiDestructuringAssignmentStatement = transformMultiDestructuringAssignmentStatement;
function findMultiAssignmentViolations(context, node) {
    const result = [];
    for (const element of node.properties) {
        if (!ts.isShorthandPropertyAssignment(element))
            continue;
        const valueSymbol = context.checker.getShorthandAssignmentValueSymbol(element);
        if (valueSymbol) {
            const declaration = valueSymbol.valueDeclaration;
            if (declaration && isMultiFunctionDeclaration(declaration)) {
                context.diagnostics.push(diagnostics_1.invalidMultiFunctionUse(element));
                result.push(element);
            }
        }
    }
    return result;
}
exports.findMultiAssignmentViolations = findMultiAssignmentViolations;
//# sourceMappingURL=multi.js.map