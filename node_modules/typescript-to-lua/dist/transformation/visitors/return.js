"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformReturnStatement = exports.transformExpressionBodyToReturnStatement = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const annotations_1 = require("../utils/annotations");
const assignment_validation_1 = require("../utils/assignment-validation");
const lua_ast_1 = require("../utils/lua-ast");
const scope_1 = require("../utils/scope");
const typescript_1 = require("../utils/typescript");
const multi_1 = require("./language-extensions/multi");
function transformExpressionsInReturn(context, node, insideTryCatch) {
    if (!annotations_1.isInTupleReturnFunction(context, node)) {
        return [context.transformExpression(node)];
    }
    let results;
    const expressionType = context.checker.getTypeAtLocation(node);
    // Parent function is a TupleReturn function
    if (ts.isArrayLiteralExpression(node)) {
        // If return expression is an array literal, leave out brackets.
        results = node.elements.map(e => context.transformExpression(e));
    }
    else if (!annotations_1.isTupleReturnCall(context, node) && typescript_1.isArrayType(context, expressionType)) {
        // If return expression is an array-type and not another TupleReturn call, unpack it
        results = [lua_ast_1.createUnpackCall(context, context.transformExpression(node), node)];
    }
    else {
        results = [context.transformExpression(node)];
    }
    // Wrap tupleReturn results when returning inside try/catch
    if (insideTryCatch) {
        results = [lua_ast_1.wrapInTable(...results)];
    }
    return results;
}
function transformExpressionBodyToReturnStatement(context, node) {
    const expressions = transformExpressionsInReturn(context, node, false);
    return lua.createReturnStatement(expressions, node);
}
exports.transformExpressionBodyToReturnStatement = transformExpressionBodyToReturnStatement;
exports.transformReturnStatement = (statement, context) => {
    // Bubble up explicit return flag and check if we're inside a try/catch block
    let insideTryCatch = false;
    for (const scope of scope_1.walkScopesUp(context)) {
        scope.functionReturned = true;
        if (scope.type === scope_1.ScopeType.Function) {
            break;
        }
        insideTryCatch = insideTryCatch || scope.type === scope_1.ScopeType.Try || scope.type === scope_1.ScopeType.Catch;
    }
    if (statement.expression &&
        ts.isCallExpression(statement.expression) &&
        multi_1.isMultiFunction(context, statement.expression)) {
        return multi_1.transformMultiReturnStatement(context, statement);
    }
    let results;
    if (statement.expression) {
        const expressionType = context.checker.getTypeAtLocation(statement.expression);
        const returnType = context.checker.getContextualType(statement.expression);
        if (returnType) {
            assignment_validation_1.validateAssignment(context, statement, expressionType, returnType);
        }
        results = transformExpressionsInReturn(context, statement.expression, insideTryCatch);
    }
    else {
        // Empty return
        results = [];
    }
    if (insideTryCatch) {
        results.unshift(lua.createBooleanLiteral(true));
    }
    return lua.createReturnStatement(results, statement);
};
//# sourceMappingURL=return.js.map