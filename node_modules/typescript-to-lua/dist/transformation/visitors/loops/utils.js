"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformForInitializer = exports.getVariableDeclarationBinding = exports.transformLoopBody = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const scope_1 = require("../../utils/scope");
const typescript_1 = require("../../utils/typescript");
const assignments_1 = require("../binary-expression/assignments");
const destructuring_assignments_1 = require("../binary-expression/destructuring-assignments");
const block_1 = require("../block");
const identifier_1 = require("../identifier");
const variable_declaration_1 = require("../variable-declaration");
function transformLoopBody(context, loop) {
    scope_1.pushScope(context, scope_1.ScopeType.Loop);
    const body = scope_1.performHoisting(context, block_1.transformBlockOrStatement(context, loop.statement));
    const scope = scope_1.popScope(context);
    const scopeId = scope.id;
    if (!scope.loopContinued) {
        return body;
    }
    const baseResult = [lua.createDoStatement(body)];
    const continueLabel = lua.createLabelStatement(`__continue${scopeId}`);
    baseResult.push(continueLabel);
    return baseResult;
}
exports.transformLoopBody = transformLoopBody;
function getVariableDeclarationBinding(context, node) {
    variable_declaration_1.checkVariableDeclarationList(context, node);
    if (node.declarations.length === 0) {
        return ts.createIdentifier("____");
    }
    return node.declarations[0].name;
}
exports.getVariableDeclarationBinding = getVariableDeclarationBinding;
function transformForInitializer(context, initializer, block) {
    const valueVariable = lua.createIdentifier("____value");
    if (ts.isVariableDeclarationList(initializer)) {
        // Declaration of new variable
        const binding = getVariableDeclarationBinding(context, initializer);
        if (ts.isArrayBindingPattern(binding) || ts.isObjectBindingPattern(binding)) {
            block.statements.unshift(...variable_declaration_1.transformBindingPattern(context, binding, valueVariable));
        }
        else {
            // Single variable declared in for loop
            return identifier_1.transformIdentifier(context, binding);
        }
    }
    else {
        // Assignment to existing variable(s)
        block.statements.unshift(...(typescript_1.isAssignmentPattern(initializer)
            ? destructuring_assignments_1.transformAssignmentPattern(context, initializer, valueVariable)
            : assignments_1.transformAssignment(context, initializer, valueVariable)));
    }
    return valueVariable;
}
exports.transformForInitializer = transformForInitializer;
//# sourceMappingURL=utils.js.map