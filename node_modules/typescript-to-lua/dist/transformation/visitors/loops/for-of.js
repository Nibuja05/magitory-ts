"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformForOfStatement = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const call_1 = require("../call");
const identifier_1 = require("../identifier");
const variable_declaration_1 = require("../variable-declaration");
const utils_2 = require("./utils");
function transformForRangeStatement(context, statement, block) {
    var _a;
    utils_1.assert(ts.isCallExpression(statement.expression));
    const callArguments = statement.expression.arguments;
    if (callArguments.length !== 2 && callArguments.length !== 3) {
        context.diagnostics.push(diagnostics_1.invalidForRangeCall(statement.expression, `Expected 2-3 arguments, but got ${callArguments.length}`));
    }
    if (statement.expression.arguments.some(a => !typescript_1.isNumberType(context, context.checker.getTypeAtLocation(a)))) {
        context.diagnostics.push(diagnostics_1.invalidForRangeCall(statement.expression, "arguments must be numbers"));
    }
    const controlVariable = (_a = getControlVariable()) !== null && _a !== void 0 ? _a : lua.createAnonymousIdentifier();
    function getControlVariable() {
        if (!ts.isVariableDeclarationList(statement.initializer)) {
            context.diagnostics.push(diagnostics_1.invalidForRangeCall(statement.initializer, "loop must declare it's own control variable"));
            return;
        }
        const binding = utils_2.getVariableDeclarationBinding(context, statement.initializer);
        if (!ts.isIdentifier(binding)) {
            context.diagnostics.push(diagnostics_1.invalidForRangeCall(statement.initializer, "destructuring cannot be used"));
            return;
        }
        if (!typescript_1.isNumberType(context, context.checker.getTypeAtLocation(binding))) {
            context.diagnostics.push(diagnostics_1.invalidForRangeCall(statement.expression, "function must return Iterable<number>"));
        }
        return identifier_1.transformIdentifier(context, binding);
    }
    const [start = lua.createNumericLiteral(0), limit = lua.createNumericLiteral(0), step] = call_1.transformArguments(context, callArguments, context.checker.getResolvedSignature(statement.expression));
    return lua.createForStatement(block, controlVariable, start, limit, step, statement);
}
function transformForOfLuaIteratorStatement(context, statement, block) {
    const luaIterator = context.transformExpression(statement.expression);
    const type = context.checker.getTypeAtLocation(statement.expression);
    const tupleReturn = annotations_1.getTypeAnnotations(type).has(annotations_1.AnnotationKind.TupleReturn);
    let identifiers = [];
    if (tupleReturn) {
        // LuaIterator + TupleReturn
        if (ts.isVariableDeclarationList(statement.initializer)) {
            // Variables declared in for loop
            // for ${initializer} in ${iterable} do
            const binding = utils_2.getVariableDeclarationBinding(context, statement.initializer);
            if (ts.isArrayBindingPattern(binding)) {
                identifiers = binding.elements.map(e => variable_declaration_1.transformArrayBindingElement(context, e));
            }
            else {
                context.diagnostics.push(diagnostics_1.luaIteratorForbiddenUsage(binding));
            }
        }
        else if (ts.isArrayLiteralExpression(statement.initializer)) {
            // Variables NOT declared in for loop - catch iterator values in temps and assign
            // for ____value0 in ${iterable} do
            //     ${initializer} = ____value0
            identifiers = statement.initializer.elements.map((_, i) => lua.createIdentifier(`____value${i}`));
            if (identifiers.length > 0) {
                block.statements.unshift(lua.createAssignmentStatement(statement.initializer.elements.map(e => utils_1.cast(context.transformExpression(e), lua.isAssignmentLeftHandSideExpression)), identifiers));
            }
        }
        else {
            context.diagnostics.push(diagnostics_1.luaIteratorForbiddenUsage(statement.initializer));
        }
    }
    else {
        // LuaIterator (no TupleReturn)
        identifiers.push(utils_2.transformForInitializer(context, statement.initializer, block));
    }
    if (identifiers.length === 0) {
        identifiers.push(lua.createAnonymousIdentifier());
    }
    return lua.createForInStatement(block, identifiers, [luaIterator], statement);
}
function transformForOfArrayStatement(context, statement, block) {
    const valueVariable = utils_2.transformForInitializer(context, statement.initializer, block);
    const ipairsCall = lua.createCallExpression(lua.createIdentifier("ipairs"), [
        context.transformExpression(statement.expression),
    ]);
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [ipairsCall], statement);
}
function transformForOfIteratorStatement(context, statement, block) {
    const valueVariable = utils_2.transformForInitializer(context, statement.initializer, block);
    const iterable = lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Iterator, statement.expression, context.transformExpression(statement.expression));
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [iterable], statement);
}
exports.transformForOfStatement = (node, context) => {
    const body = lua.createBlock(utils_2.transformLoopBody(context, node));
    if (ts.isCallExpression(node.expression) && annotations_1.isForRangeType(context, node.expression.expression)) {
        return transformForRangeStatement(context, node, body);
    }
    else if (annotations_1.isLuaIteratorType(context, node.expression)) {
        return transformForOfLuaIteratorStatement(context, node, body);
    }
    else if (typescript_1.isArrayType(context, context.checker.getTypeAtLocation(node.expression))) {
        return transformForOfArrayStatement(context, node, body);
    }
    else {
        return transformForOfIteratorStatement(context, node, body);
    }
};
//# sourceMappingURL=for-of.js.map