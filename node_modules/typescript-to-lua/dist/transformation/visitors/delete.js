"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformDeleteExpression = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const lualib_1 = require("../utils/lualib");
const diagnostics_1 = require("../utils/diagnostics");
const typescript_1 = require("../utils/typescript");
const lua_ast_1 = require("../utils/lua-ast");
exports.transformDeleteExpression = (node, context) => {
    let ownerExpression;
    let propertyExpression;
    if (ts.isPropertyAccessExpression(node.expression)) {
        if (ts.isPrivateIdentifier(node.expression.name))
            throw new Error("PrivateIdentifier is not supported");
        ownerExpression = context.transformExpression(node.expression.expression);
        propertyExpression = lua.createStringLiteral(node.expression.name.text);
    }
    else if (ts.isElementAccessExpression(node.expression)) {
        ownerExpression = context.transformExpression(node.expression.expression);
        propertyExpression = context.transformExpression(node.expression.argumentExpression);
        const type = context.checker.getTypeAtLocation(node.expression.expression);
        const argumentType = context.checker.getTypeAtLocation(node.expression.argumentExpression);
        if (typescript_1.isArrayType(context, type) && typescript_1.isNumberType(context, argumentType)) {
            propertyExpression = lua_ast_1.addToNumericExpression(propertyExpression, 1);
        }
    }
    if (!ownerExpression || !propertyExpression) {
        context.diagnostics.push(diagnostics_1.unsupportedProperty(node, "delete", ts.SyntaxKind[node.kind]));
        return lua.createNilLiteral();
    }
    return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Delete, node, ownerExpression, propertyExpression);
};
//# sourceMappingURL=delete.js.map