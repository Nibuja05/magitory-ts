"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformLuaTableNewExpression = exports.validateLuaTableElementAccessExpression = exports.transformLuaTablePropertyAccessInAssignment = exports.transformLuaTablePropertyAccessExpression = exports.transformLuaTableCallExpression = exports.transformLuaTableExpressionStatement = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const annotations_1 = require("../utils/annotations");
const diagnostics_1 = require("../utils/diagnostics");
const call_1 = require("./call");
const parseLuaTableExpression = (context, node) => [context.transformExpression(node.expression), node.name.text];
function validateLuaTableCall(context, node, methodName, callArguments) {
    for (const argument of callArguments) {
        if (ts.isSpreadElement(argument)) {
            context.diagnostics.push(diagnostics_1.luaTableForbiddenUsage(argument, "Arguments cannot be spread"));
            return;
        }
    }
    switch (methodName) {
        case "get":
            if (callArguments.length !== 1) {
                context.diagnostics.push(diagnostics_1.luaTableForbiddenUsage(node, `Expected 1 arguments, but got ${callArguments.length}`));
            }
            break;
        case "set":
            if (callArguments.length !== 2) {
                context.diagnostics.push(diagnostics_1.luaTableForbiddenUsage(node, `Expected 2 arguments, but got ${callArguments.length}`));
            }
            break;
    }
}
function transformLuaTableExpressionStatement(context, node) {
    var _a, _b, _c;
    const expression = ts.isExpressionStatement(node) ? node.expression : node;
    if (!ts.isCallExpression(expression) || !ts.isPropertyAccessExpression(expression.expression))
        return;
    const ownerType = context.checker.getTypeAtLocation(expression.expression.expression);
    const annotations = annotations_1.getTypeAnnotations(ownerType);
    if (!annotations.has(annotations_1.AnnotationKind.LuaTable))
        return;
    const [luaTable, methodName] = parseLuaTableExpression(context, expression.expression);
    validateLuaTableCall(context, expression, methodName, expression.arguments);
    const signature = context.checker.getResolvedSignature(expression);
    const params = call_1.transformArguments(context, expression.arguments, signature);
    switch (methodName) {
        case "get":
            return lua.createVariableDeclarationStatement(lua.createAnonymousIdentifier(expression), lua.createTableIndexExpression(luaTable, (_a = params[0]) !== null && _a !== void 0 ? _a : lua.createNilLiteral(), expression), expression);
        case "set":
            return lua.createAssignmentStatement(lua.createTableIndexExpression(luaTable, (_b = params[0]) !== null && _b !== void 0 ? _b : lua.createNilLiteral(), expression), [(_c = params[1]) !== null && _c !== void 0 ? _c : lua.createNilLiteral()], expression);
        default:
            context.diagnostics.push(diagnostics_1.unsupportedProperty(expression.expression.name, "LuaTable", methodName));
    }
}
exports.transformLuaTableExpressionStatement = transformLuaTableExpressionStatement;
function transformLuaTableCallExpression(context, node) {
    var _a;
    if (!ts.isPropertyAccessExpression(node.expression))
        return;
    const ownerType = context.checker.getTypeAtLocation(node.expression.expression);
    const annotations = annotations_1.getTypeAnnotations(ownerType);
    if (!annotations.has(annotations_1.AnnotationKind.LuaTable))
        return;
    const [luaTable, methodName] = parseLuaTableExpression(context, node.expression);
    validateLuaTableCall(context, node, methodName, node.arguments);
    const signature = context.checker.getResolvedSignature(node);
    const params = call_1.transformArguments(context, node.arguments, signature);
    switch (methodName) {
        case "get":
            return lua.createTableIndexExpression(luaTable, (_a = params[0]) !== null && _a !== void 0 ? _a : lua.createNilLiteral(), node);
        default:
            context.diagnostics.push(diagnostics_1.unsupportedProperty(node.expression.name, "LuaTable", methodName));
    }
}
exports.transformLuaTableCallExpression = transformLuaTableCallExpression;
function transformLuaTablePropertyAccessExpression(context, node) {
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(node.expression));
    if (!annotations.has(annotations_1.AnnotationKind.LuaTable))
        return;
    const [luaTable, propertyName] = parseLuaTableExpression(context, node);
    if (propertyName === "length") {
        return lua.createUnaryExpression(luaTable, lua.SyntaxKind.LengthOperator, node);
    }
    context.diagnostics.push(diagnostics_1.unsupportedProperty(node.name, "LuaTable", propertyName));
}
exports.transformLuaTablePropertyAccessExpression = transformLuaTablePropertyAccessExpression;
function transformLuaTablePropertyAccessInAssignment(context, node) {
    if (!ts.isPropertyAccessExpression(node))
        return;
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(node.expression));
    if (!annotations.has(annotations_1.AnnotationKind.LuaTable))
        return;
    const [luaTable, propertyName] = parseLuaTableExpression(context, node);
    if (propertyName === "length") {
        context.diagnostics.push(diagnostics_1.luaTableForbiddenUsage(node, "A LuaTable object's length cannot be re-assigned"));
        return lua.createTableIndexExpression(luaTable, lua.createStringLiteral(propertyName), node);
    }
    context.diagnostics.push(diagnostics_1.unsupportedProperty(node.name, "LuaTable", propertyName));
}
exports.transformLuaTablePropertyAccessInAssignment = transformLuaTablePropertyAccessInAssignment;
function validateLuaTableElementAccessExpression(context, node) {
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(node.expression));
    if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
        context.diagnostics.push(diagnostics_1.luaTableCannotBeAccessedDynamically(node));
    }
}
exports.validateLuaTableElementAccessExpression = validateLuaTableElementAccessExpression;
function transformLuaTableNewExpression(context, node) {
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(node));
    if (!annotations.has(annotations_1.AnnotationKind.LuaTable))
        return;
    if (node.arguments && node.arguments.length > 0) {
        context.diagnostics.push(diagnostics_1.luaTableForbiddenUsage(node, "No parameters are allowed when constructing a LuaTable object"));
    }
    return lua.createTableExpression();
}
exports.transformLuaTableNewExpression = transformLuaTableNewExpression;
//# sourceMappingURL=lua-table.js.map