"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformExpressionStatement = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const binary_expression_1 = require("./binary-expression");
const lua_table_1 = require("./lua-table");
const unary_expression_1 = require("./unary-expression");
const multi_1 = require("./language-extensions/multi");
exports.transformExpressionStatement = (node, context) => {
    if (ts.isBinaryExpression(node.expression) &&
        node.expression.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
        ts.isCallExpression(node.expression.right) &&
        multi_1.returnsMultiType(context, node.expression.right)) {
        return multi_1.transformMultiDestructuringAssignmentStatement(context, node);
    }
    const luaTableResult = lua_table_1.transformLuaTableExpressionStatement(context, node);
    if (luaTableResult) {
        return luaTableResult;
    }
    const unaryExpressionResult = unary_expression_1.transformUnaryExpressionStatement(context, node);
    if (unaryExpressionResult) {
        return unaryExpressionResult;
    }
    const binaryExpressionResult = binary_expression_1.transformBinaryExpressionStatement(context, node);
    if (binaryExpressionResult) {
        return binaryExpressionResult;
    }
    const expression = ts.isExpressionStatement(node) ? node.expression : node;
    const result = context.transformExpression(expression);
    return lua.isCallExpression(result) || lua.isMethodCallExpression(result)
        ? lua.createExpressionStatement(result)
        : // Assign expression statements to dummy to make sure they're legal Lua
            lua.createVariableDeclarationStatement(lua.createAnonymousIdentifier(), result);
};
//# sourceMappingURL=expression-statement.js.map