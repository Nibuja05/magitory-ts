"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformModuleDeclaration = exports.createModuleLocalNameIdentifier = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const annotations_1 = require("../utils/annotations");
const diagnostics_1 = require("../utils/diagnostics");
const export_1 = require("../utils/export");
const lua_ast_1 = require("../utils/lua-ast");
const safe_names_1 = require("../utils/safe-names");
const scope_1 = require("../utils/scope");
const symbols_1 = require("../utils/symbols");
const identifier_1 = require("./identifier");
function createModuleLocalNameIdentifier(context, declaration) {
    const moduleSymbol = context.checker.getSymbolAtLocation(declaration.name);
    if (moduleSymbol !== undefined && safe_names_1.isUnsafeName(moduleSymbol.name)) {
        return lua.createIdentifier(safe_names_1.createSafeName(declaration.name.text), declaration.name, moduleSymbol && symbols_1.getSymbolIdOfSymbol(context, moduleSymbol), declaration.name.text);
    }
    // TODO: Should synthetic name nodes be escaped as well?
    return identifier_1.transformIdentifier(context, declaration.name);
}
exports.createModuleLocalNameIdentifier = createModuleLocalNameIdentifier;
// TODO: Do it based on transform result?
function moduleHasEmittedBody(node) {
    if (node.body) {
        if (ts.isModuleBlock(node.body)) {
            // Ignore if body has no emitted statements
            return node.body.statements.some(s => !ts.isInterfaceDeclaration(s) && !ts.isTypeAliasDeclaration(s));
        }
        else if (ts.isModuleDeclaration(node.body)) {
            return true;
        }
    }
    return false;
}
// Static context -> namespace dictionary keeping the current namespace for each transformation context
const currentNamespaces = new WeakMap();
exports.transformModuleDeclaration = (node, context) => {
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(node));
    // If phantom namespace elide the declaration and return the body
    if (annotations.has(annotations_1.AnnotationKind.Phantom) && node.body && ts.isModuleBlock(node.body)) {
        context.diagnostics.push(diagnostics_1.annotationDeprecated(node, annotations_1.AnnotationKind.Phantom));
        return context.transformStatements(node.body.statements);
    }
    const currentNamespace = currentNamespaces.get(context);
    const result = [];
    const symbol = context.checker.getSymbolAtLocation(node.name);
    const hasExports = symbol !== undefined && context.checker.getExportsOfModule(symbol).length > 0;
    const nameIdentifier = identifier_1.transformIdentifier(context, node.name);
    const exportScope = export_1.getIdentifierExportScope(context, nameIdentifier);
    // Non-module namespace could be merged if:
    // - is top level
    // - is nested and exported
    const isNonModuleMergeable = !context.isModule && (!currentNamespace || exportScope);
    // This is NOT the first declaration if:
    // - declared as a module before this (ignore interfaces with same name)
    // - declared as a class or function at all (TS requires these to be before module, unless module is empty)
    const isFirstDeclaration = symbol === undefined ||
        (!symbol.declarations.some(d => ts.isClassLike(d) || ts.isFunctionDeclaration(d)) &&
            node === symbol.declarations.find(ts.isModuleDeclaration));
    if (isNonModuleMergeable) {
        // 'local NS = NS or {}' or 'exportTable.NS = exportTable.NS or {}'
        const localDeclaration = lua_ast_1.createLocalOrExportedOrGlobalDeclaration(context, nameIdentifier, lua.createBinaryExpression(export_1.addExportToIdentifier(context, nameIdentifier), lua.createTableExpression(), lua.SyntaxKind.OrOperator));
        result.push(...localDeclaration);
    }
    else if (isFirstDeclaration) {
        // local NS = {} or exportTable.NS = {}
        const localDeclaration = lua_ast_1.createLocalOrExportedOrGlobalDeclaration(context, nameIdentifier, lua.createTableExpression());
        result.push(...localDeclaration);
    }
    if ((isNonModuleMergeable || isFirstDeclaration) && exportScope && hasExports && moduleHasEmittedBody(node)) {
        // local NS = exportTable.NS
        const localDeclaration = lua_ast_1.createHoistableVariableDeclarationStatement(context, createModuleLocalNameIdentifier(context, node), export_1.createExportedIdentifier(context, nameIdentifier, exportScope));
        result.push(localDeclaration);
    }
    // Set current namespace for nested NS
    // Keep previous namespace to reset after block transpilation
    currentNamespaces.set(context, node);
    // Transform moduleblock to block and visit it
    if (moduleHasEmittedBody(node)) {
        scope_1.pushScope(context, scope_1.ScopeType.Block);
        const statements = scope_1.performHoisting(context, context.transformStatements(ts.isModuleBlock(node.body) ? node.body.statements : node.body));
        scope_1.popScope(context);
        result.push(lua.createDoStatement(statements));
    }
    currentNamespaces.set(context, currentNamespace);
    return result;
};
//# sourceMappingURL=namespace.js.map