"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformNewExpression = exports.checkForLuaLibType = void 0;
const lua = require("../../../LuaAST");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const lualib_1 = require("../../utils/lualib");
const call_1 = require("../call");
const lua_table_1 = require("../lua-table");
const builtinErrorTypeNames = new Set([
    "Error",
    "ErrorConstructor",
    "RangeError",
    "RangeErrorConstructor",
    "ReferenceError",
    "ReferenceErrorConstructor",
    "SyntaxError",
    "SyntaxErrorConstructor",
    "TypeError",
    "TypeErrorConstructor",
    "URIError",
    "URIErrorConstructor",
]);
// TODO: Do it in identifier?
function checkForLuaLibType(context, type) {
    if (!type.symbol)
        return;
    const name = context.checker.getFullyQualifiedName(type.symbol);
    switch (name) {
        case "Map":
            lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.Map);
            return;
        case "Set":
            lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.Set);
            return;
        case "WeakMap":
            lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.WeakMap);
            return;
        case "WeakSet":
            lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.WeakSet);
            return;
    }
    if (builtinErrorTypeNames.has(name)) {
        lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.Error);
    }
}
exports.checkForLuaLibType = checkForLuaLibType;
exports.transformNewExpression = (node, context) => {
    var _a;
    const luaTableResult = lua_table_1.transformLuaTableNewExpression(context, node);
    if (luaTableResult) {
        return luaTableResult;
    }
    const name = context.transformExpression(node.expression);
    const signature = context.checker.getResolvedSignature(node);
    const params = node.arguments
        ? call_1.transformArguments(context, node.arguments, signature)
        : [lua.createBooleanLiteral(true)];
    const type = context.checker.getTypeAtLocation(node);
    checkForLuaLibType(context, type);
    const annotations = annotations_1.getTypeAnnotations(type);
    if (annotations.has(annotations_1.AnnotationKind.Extension) || annotations.has(annotations_1.AnnotationKind.MetaExtension)) {
        context.diagnostics.push(diagnostics_1.extensionCannotConstruct(node));
    }
    const customConstructorAnnotation = annotations.get(annotations_1.AnnotationKind.CustomConstructor);
    if (customConstructorAnnotation) {
        if (customConstructorAnnotation.args.length === 1) {
            return lua.createCallExpression(lua.createIdentifier(customConstructorAnnotation.args[0]), call_1.transformArguments(context, (_a = node.arguments) !== null && _a !== void 0 ? _a : []), node);
        }
        else {
            context.diagnostics.push(diagnostics_1.annotationInvalidArgumentCount(node, annotations_1.AnnotationKind.CustomConstructor, customConstructorAnnotation.args.length, 1));
        }
    }
    return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.New, node, name, ...params);
};
//# sourceMappingURL=new.js.map