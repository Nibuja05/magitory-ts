"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSuperExpression = exports.transformClassAsExpression = exports.transformThisExpression = exports.transformClassDeclaration = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const safe_names_1 = require("../../utils/safe-names");
const scope_1 = require("../../utils/scope");
const typescript_1 = require("../../utils/typescript");
const identifier_1 = require("../identifier");
const literal_1 = require("../literal");
const decorators_1 = require("./decorators");
const accessors_1 = require("./members/accessors");
const constructor_1 = require("./members/constructor");
const fields_1 = require("./members/fields");
const method_1 = require("./members/method");
const new_1 = require("./new");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
exports.transformClassDeclaration = (declaration, context) => {
    // If declaration is a default export, transform to export variable assignment instead
    if (export_1.hasDefaultExportModifier(declaration)) {
        const left = export_1.createExportedIdentifier(context, export_1.createDefaultExportIdentifier(declaration));
        const right = transformClassAsExpression(declaration, context);
        return [lua.createAssignmentStatement(left, right, declaration)];
    }
    const { statements } = transformClassLikeDeclaration(declaration, context);
    return statements;
};
exports.transformThisExpression = node => lua_ast_1.createSelfIdentifier(node);
function transformClassAsExpression(expression, context) {
    scope_1.pushScope(context, scope_1.ScopeType.Function);
    const { statements, name } = transformClassLikeDeclaration(expression, context);
    scope_1.popScope(context);
    return lua_ast_1.createImmediatelyInvokedFunctionExpression(lua_ast_1.unwrapVisitorResult(statements), name, expression);
}
exports.transformClassAsExpression = transformClassAsExpression;
const classSuperInfos = new WeakMap();
function transformClassLikeDeclaration(classDeclaration, context, nameOverride) {
    let className;
    if (nameOverride !== undefined) {
        className = nameOverride;
    }
    else if (classDeclaration.name !== undefined) {
        className = identifier_1.transformIdentifier(context, classDeclaration.name);
    }
    else {
        // TypeScript error
        className = lua.createAnonymousIdentifier();
    }
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(classDeclaration));
    // Find out if this class is extension of existing class
    const extensionDirective = annotations.get(annotations_1.AnnotationKind.Extension);
    const isExtension = extensionDirective !== undefined;
    const isMetaExtension = annotations.has(annotations_1.AnnotationKind.MetaExtension);
    if (isExtension) {
        context.diagnostics.push(diagnostics_1.annotationDeprecated(classDeclaration, annotations_1.AnnotationKind.Extension));
    }
    if (isMetaExtension) {
        context.diagnostics.push(diagnostics_1.annotationDeprecated(classDeclaration, annotations_1.AnnotationKind.MetaExtension));
    }
    if (isExtension && isMetaExtension) {
        context.diagnostics.push(diagnostics_1.extensionAndMetaExtensionConflict(classDeclaration));
    }
    if ((isExtension || isMetaExtension) && export_1.getIdentifierExportScope(context, className) !== undefined) {
        // Cannot export extension classes
        context.diagnostics.push(diagnostics_1.extensionCannotExport(classDeclaration));
    }
    // Get type that is extended
    const extendedTypeNode = utils_2.getExtendedNode(context, classDeclaration);
    const extendedType = utils_2.getExtendedType(context, classDeclaration);
    const superInfo = utils_1.getOrUpdate(classSuperInfos, context, () => []);
    superInfo.push({ className, extendedTypeNode });
    if (extendedType) {
        new_1.checkForLuaLibType(context, extendedType);
    }
    if (!(isExtension || isMetaExtension) && extendedType) {
        // Non-extensions cannot extend extension classes
        const extendsAnnotations = annotations_1.getTypeAnnotations(extendedType);
        if (extendsAnnotations.has(annotations_1.AnnotationKind.Extension) || extendsAnnotations.has(annotations_1.AnnotationKind.MetaExtension)) {
            context.diagnostics.push(diagnostics_1.extensionCannotExtend(classDeclaration));
        }
    }
    // You cannot extend LuaTable classes
    if (extendedType) {
        const annotations = annotations_1.getTypeAnnotations(extendedType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            context.diagnostics.push(diagnostics_1.luaTableCannotBeExtended(extendedTypeNode));
        }
    }
    if (annotations.has(annotations_1.AnnotationKind.LuaTable) && !typescript_1.isAmbientNode(classDeclaration)) {
        context.diagnostics.push(diagnostics_1.luaTableMustBeAmbient(classDeclaration));
    }
    // Get all properties with value
    const properties = classDeclaration.members.filter(ts.isPropertyDeclaration).filter(member => member.initializer);
    // Divide properties into static and non-static
    const instanceFields = properties.filter(prop => !utils_2.isStaticNode(prop));
    const result = [];
    // Overwrite the original className with the class we are overriding for extensions
    if (isMetaExtension) {
        if (extendedType) {
            const extendsName = lua.createStringLiteral(extendedType.symbol.name);
            className = lua.createIdentifier("__meta__" + extendsName.value);
            // local className = debug.getregistry()["extendsName"]
            const assignDebugCallIndex = lua.createVariableDeclarationStatement(className, lua.createTableIndexExpression(lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("debug"), lua.createStringLiteral("getregistry")), []), extendsName), classDeclaration);
            result.push(assignDebugCallIndex);
        }
        else {
            context.diagnostics.push(diagnostics_1.metaExtensionMissingExtends(classDeclaration));
        }
    }
    if (extensionDirective !== undefined) {
        const [extensionName] = extensionDirective.args;
        if (extensionName) {
            className = lua.createIdentifier(extensionName);
        }
        else if (extendedType) {
            className = lua.createIdentifier(extendedType.symbol.name);
        }
    }
    let localClassName;
    if (safe_names_1.isUnsafeName(className.text)) {
        localClassName = lua.createIdentifier(safe_names_1.createSafeName(className.text), undefined, className.symbolId, className.text);
        lua.setNodePosition(localClassName, className);
    }
    else {
        localClassName = className;
    }
    if (!isExtension && !isMetaExtension) {
        result.push(...setup_1.createClassSetup(context, classDeclaration, className, localClassName, extendedType));
    }
    else {
        for (const f of instanceFields) {
            const fieldName = literal_1.transformPropertyName(context, f.name);
            const value = f.initializer !== undefined ? context.transformExpression(f.initializer) : undefined;
            // className["fieldName"]
            const classField = lua.createTableIndexExpression(lua.cloneIdentifier(className), fieldName);
            // className["fieldName"] = value;
            const assignClassField = lua.createAssignmentStatement(classField, value);
            result.push(assignClassField);
        }
    }
    // Find first constructor with body
    if (!isExtension && !isMetaExtension) {
        const constructor = classDeclaration.members.find((n) => ts.isConstructorDeclaration(n) && n.body !== undefined);
        if (constructor) {
            // Add constructor plus initialization of instance fields
            const constructorResult = constructor_1.transformConstructorDeclaration(context, constructor, localClassName, instanceFields, classDeclaration);
            if (constructorResult)
                result.push(constructorResult);
        }
        else if (!extendedType) {
            // Generate a constructor if none was defined in a base class
            const constructorResult = constructor_1.transformConstructorDeclaration(context, ts.createConstructor([], [], [], ts.createBlock([], true)), localClassName, instanceFields, classDeclaration);
            if (constructorResult)
                result.push(constructorResult);
        }
        else if (instanceFields.length > 0) {
            // Generate a constructor if none was defined in a class with instance fields that need initialization
            // localClassName.prototype.____constructor = function(self, ...)
            //     baseClassName.prototype.____constructor(self, ...)
            //     ...
            const constructorBody = fields_1.transformClassInstanceFields(context, instanceFields);
            const superCall = lua.createExpressionStatement(lua.createCallExpression(lua.createTableIndexExpression(context.transformExpression(ts.createSuper()), lua.createStringLiteral("____constructor")), [lua_ast_1.createSelfIdentifier(), lua.createDotsLiteral()]));
            constructorBody.unshift(superCall);
            const constructorFunction = lua.createFunctionExpression(lua.createBlock(constructorBody), [lua_ast_1.createSelfIdentifier()], lua.createDotsLiteral(), lua.FunctionExpressionFlags.Declaration);
            result.push(lua.createAssignmentStatement(constructor_1.createConstructorName(localClassName), constructorFunction, classDeclaration));
        }
    }
    // Transform accessors
    for (const member of classDeclaration.members) {
        if (!ts.isAccessor(member))
            continue;
        const accessors = context.resolver.getAllAccessorDeclarations(member);
        if (accessors.firstAccessor !== member)
            continue;
        const accessorsResult = accessors_1.transformAccessorDeclarations(context, accessors, localClassName);
        if (accessorsResult) {
            result.push(accessorsResult);
        }
    }
    const noPrototype = isExtension || isMetaExtension;
    const decorationStatements = [];
    for (const member of classDeclaration.members) {
        if (ts.isAccessor(member)) {
            const expression = fields_1.createPropertyDecoratingExpression(context, member, localClassName, noPrototype);
            if (expression)
                decorationStatements.push(lua.createExpressionStatement(expression));
        }
        else if (ts.isMethodDeclaration(member)) {
            const statement = method_1.transformMethodDeclaration(context, member, localClassName, noPrototype);
            if (statement)
                result.push(statement);
            if (member.body) {
                const statement = method_1.createMethodDecoratingExpression(context, member, localClassName, noPrototype);
                if (statement)
                    decorationStatements.push(statement);
            }
        }
        else if (ts.isPropertyDeclaration(member)) {
            if (utils_2.isStaticNode(member)) {
                const statement = fields_1.transformStaticPropertyDeclaration(context, member, localClassName);
                if (statement)
                    decorationStatements.push(statement);
            }
            const expression = fields_1.createPropertyDecoratingExpression(context, member, localClassName, noPrototype);
            if (expression)
                decorationStatements.push(lua.createExpressionStatement(expression));
        }
    }
    result.push(...decorationStatements);
    // Decorate the class
    if (classDeclaration.decorators) {
        const decoratingExpression = decorators_1.createDecoratingExpression(context, classDeclaration.kind, classDeclaration.decorators.map(d => decorators_1.transformDecoratorExpression(context, d)), localClassName);
        const decoratingStatement = lua.createAssignmentStatement(localClassName, decoratingExpression);
        result.push(decoratingStatement);
    }
    superInfo.pop();
    return { statements: result, name: className };
}
exports.transformSuperExpression = (expression, context) => {
    const superInfos = utils_1.getOrUpdate(classSuperInfos, context, () => []);
    const superInfo = superInfos[superInfos.length - 1];
    if (!superInfo)
        return lua.createAnonymousIdentifier(expression);
    const { className, extendedTypeNode } = superInfo;
    // Using `super` without extended type node is a TypeScript error
    const extendsExpression = extendedTypeNode === null || extendedTypeNode === void 0 ? void 0 : extendedTypeNode.expression;
    let baseClassName;
    if (extendsExpression && ts.isIdentifier(extendsExpression)) {
        const symbol = context.checker.getSymbolAtLocation(extendsExpression);
        if (symbol && !export_1.isSymbolExported(context, symbol)) {
            // Use "baseClassName" if base is a simple identifier
            baseClassName = identifier_1.transformIdentifier(context, extendsExpression);
        }
    }
    if (!baseClassName) {
        // Use "className.____super" if the base is not a simple identifier
        baseClassName = lua.createTableIndexExpression(className, lua.createStringLiteral("____super"), expression);
    }
    return lua.createTableIndexExpression(baseClassName, lua.createStringLiteral("prototype"));
};
//# sourceMappingURL=index.js.map