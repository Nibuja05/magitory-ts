"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSwitchStatement = void 0;
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
const lua = require("../../LuaAST");
const diagnostics_1 = require("../utils/diagnostics");
const scope_1 = require("../utils/scope");
exports.transformSwitchStatement = (statement, context) => {
    if (context.luaTarget === CompilerOptions_1.LuaTarget.Universal || context.luaTarget === CompilerOptions_1.LuaTarget.Lua51) {
        context.diagnostics.push(diagnostics_1.unsupportedForTarget(statement, "Switch statements", CompilerOptions_1.LuaTarget.Lua51));
    }
    const scope = scope_1.pushScope(context, scope_1.ScopeType.Switch);
    // Give the switch a unique name to prevent nested switches from acting up.
    const switchName = `____switch${scope.id}`;
    const switchVariable = lua.createIdentifier(switchName);
    let statements = [];
    const caseClauses = statement.caseBlock.clauses.filter(ts.isCaseClause);
    // Starting from the back, concatenating ifs into one big if/elseif statement
    const concatenatedIf = caseClauses.reduceRight((previousCondition, clause, index) => {
        // If the clause condition holds, go to the correct label
        const condition = lua.createBinaryExpression(switchVariable, context.transformExpression(clause.expression), lua.SyntaxKind.EqualityOperator);
        const goto = lua.createGotoStatement(`${switchName}_case_${index}`);
        return lua.createIfStatement(condition, lua.createBlock([goto]), previousCondition);
    }, undefined);
    if (concatenatedIf) {
        statements.push(concatenatedIf);
    }
    const hasDefaultCase = statement.caseBlock.clauses.some(ts.isDefaultClause);
    statements.push(lua.createGotoStatement(`${switchName}_${hasDefaultCase ? "case_default" : "end"}`));
    for (const [index, clause] of statement.caseBlock.clauses.entries()) {
        const labelName = `${switchName}_case_${ts.isCaseClause(clause) ? index : "default"}`;
        statements.push(lua.createLabelStatement(labelName));
        statements.push(lua.createDoStatement(context.transformStatements(clause.statements)));
    }
    statements.push(lua.createLabelStatement(`${switchName}_end`));
    statements = scope_1.performHoisting(context, statements);
    scope_1.popScope(context);
    const expression = context.transformExpression(statement.expression);
    statements.unshift(lua.createVariableDeclarationStatement(switchVariable, expression));
    return statements;
};
//# sourceMappingURL=switch.js.map