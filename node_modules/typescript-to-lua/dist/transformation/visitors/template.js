"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTaggedTemplateExpression = exports.transformTemplateExpression = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const function_context_1 = require("../utils/function-context");
const lua_ast_1 = require("../utils/lua-ast");
const types_1 = require("../utils/typescript/types");
const call_1 = require("./call");
// TODO: Source positions
function getRawLiteral(node) {
    let text = node.getText();
    const isLast = node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral || node.kind === ts.SyntaxKind.TemplateTail;
    text = text.substring(1, text.length - (isLast ? 1 : 2));
    text = text.replace(/\r\n?/g, "\n");
    return text;
}
exports.transformTemplateExpression = (node, context) => {
    const parts = [];
    const head = node.head.text;
    if (head.length > 0) {
        parts.push(lua.createStringLiteral(head, node.head));
    }
    for (const span of node.templateSpans) {
        const expression = context.transformExpression(span.expression);
        const spanType = context.checker.getTypeAtLocation(span.expression);
        if (types_1.isStringType(context, spanType)) {
            parts.push(expression);
        }
        else {
            parts.push(lua_ast_1.wrapInToStringForConcat(expression));
        }
        const text = span.literal.text;
        if (text.length > 0) {
            parts.push(lua.createStringLiteral(text, span.literal));
        }
    }
    return parts.reduce((prev, current) => lua.createBinaryExpression(prev, current, lua.SyntaxKind.ConcatOperator));
};
exports.transformTaggedTemplateExpression = (expression, context) => {
    const strings = [];
    const rawStrings = [];
    const expressions = [];
    if (ts.isTemplateExpression(expression.template)) {
        // Expressions are in the string.
        strings.push(expression.template.head.text);
        rawStrings.push(getRawLiteral(expression.template.head));
        strings.push(...expression.template.templateSpans.map(span => span.literal.text));
        rawStrings.push(...expression.template.templateSpans.map(span => getRawLiteral(span.literal)));
        expressions.push(...expression.template.templateSpans.map(span => span.expression));
    }
    else {
        // No expressions are in the string.
        strings.push(expression.template.text);
        rawStrings.push(getRawLiteral(expression.template));
    }
    // Construct table with strings and literal strings
    const rawStringsTable = lua.createTableExpression(rawStrings.map(text => lua.createTableFieldExpression(lua.createStringLiteral(text))));
    const stringTableLiteral = lua.createTableExpression([
        ...strings.map(partialString => lua.createTableFieldExpression(lua.createStringLiteral(partialString))),
        lua.createTableFieldExpression(rawStringsTable, lua.createStringLiteral("raw")),
    ]);
    // Evaluate if there is a self parameter to be used.
    const signature = context.checker.getResolvedSignature(expression);
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    const useSelfParameter = signatureDeclaration && function_context_1.getDeclarationContextType(context, signatureDeclaration) !== function_context_1.ContextType.Void;
    // Argument evaluation.
    const callArguments = call_1.transformArguments(context, expressions, signature);
    callArguments.unshift(stringTableLiteral);
    if (useSelfParameter) {
        return call_1.transformContextualCallExpression(context, expression, callArguments);
    }
    const leftHandSideExpression = context.transformExpression(expression.tag);
    return lua.createCallExpression(leftHandSideExpression, callArguments);
};
//# sourceMappingURL=template.js.map