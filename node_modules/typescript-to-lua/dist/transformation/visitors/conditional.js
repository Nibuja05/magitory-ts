"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformIfStatement = exports.transformConditionalExpression = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const scope_1 = require("../utils/scope");
const block_1 = require("./block");
function canBeFalsy(context, type) {
    const strictNullChecks = context.options.strict === true || context.options.strictNullChecks === true;
    const falsyFlags = ts.TypeFlags.Boolean |
        ts.TypeFlags.BooleanLiteral |
        ts.TypeFlags.Undefined |
        ts.TypeFlags.Null |
        ts.TypeFlags.Never |
        ts.TypeFlags.Void |
        ts.TypeFlags.Any;
    if (type.flags & falsyFlags) {
        return true;
    }
    else if (!strictNullChecks && !type.isLiteral()) {
        return true;
    }
    else if (type.isUnion()) {
        return type.types.some(subType => canBeFalsy(context, subType));
    }
    else {
        return false;
    }
}
function wrapInFunctionCall(expression) {
    const returnStatement = lua.createReturnStatement([expression]);
    return lua.createFunctionExpression(lua.createBlock([returnStatement]), undefined, undefined, lua.FunctionExpressionFlags.Inline);
}
function transformProtectedConditionalExpression(context, expression) {
    const condition = context.transformExpression(expression.condition);
    const val1 = context.transformExpression(expression.whenTrue);
    const val2 = context.transformExpression(expression.whenFalse);
    const val1Function = wrapInFunctionCall(val1);
    const val2Function = wrapInFunctionCall(val2);
    // (condition and (() => v1) or (() => v2))()
    const conditionAnd = lua.createBinaryExpression(condition, val1Function, lua.SyntaxKind.AndOperator);
    const orExpression = lua.createBinaryExpression(conditionAnd, val2Function, lua.SyntaxKind.OrOperator);
    return lua.createCallExpression(orExpression, [], expression);
}
exports.transformConditionalExpression = (expression, context) => {
    if (canBeFalsy(context, context.checker.getTypeAtLocation(expression.whenTrue))) {
        return transformProtectedConditionalExpression(context, expression);
    }
    const condition = context.transformExpression(expression.condition);
    const val1 = context.transformExpression(expression.whenTrue);
    const val2 = context.transformExpression(expression.whenFalse);
    // condition and v1 or v2
    const conditionAnd = lua.createBinaryExpression(condition, val1, lua.SyntaxKind.AndOperator);
    return lua.createBinaryExpression(conditionAnd, val2, lua.SyntaxKind.OrOperator, expression);
};
function transformIfStatement(statement, context) {
    scope_1.pushScope(context, scope_1.ScopeType.Conditional);
    const condition = context.transformExpression(statement.expression);
    const statements = scope_1.performHoisting(context, block_1.transformBlockOrStatement(context, statement.thenStatement));
    scope_1.popScope(context);
    const ifBlock = lua.createBlock(statements);
    if (statement.elseStatement) {
        if (ts.isIfStatement(statement.elseStatement)) {
            const elseStatement = transformIfStatement(statement.elseStatement, context);
            return lua.createIfStatement(condition, ifBlock, elseStatement);
        }
        else {
            scope_1.pushScope(context, scope_1.ScopeType.Conditional);
            const elseStatements = scope_1.performHoisting(context, block_1.transformBlockOrStatement(context, statement.elseStatement));
            scope_1.popScope(context);
            const elseBlock = lua.createBlock(elseStatements);
            return lua.createIfStatement(condition, ifBlock, elseBlock);
        }
    }
    return lua.createIfStatement(condition, ifBlock);
}
exports.transformIfStatement = transformIfStatement;
//# sourceMappingURL=conditional.js.map