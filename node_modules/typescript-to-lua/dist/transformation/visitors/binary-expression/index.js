"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformBinaryExpressionStatement = exports.transformBinaryExpression = exports.transformBinaryOperation = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const lua_ast_1 = require("../../utils/lua-ast");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const typeof_1 = require("../typeof");
const assignments_1 = require("./assignments");
const bit_1 = require("./bit");
const compound_1 = require("./compound");
const utils_1 = require("../../../utils");
const simpleOperatorsToLua = {
    [ts.SyntaxKind.AmpersandAmpersandToken]: lua.SyntaxKind.AndOperator,
    [ts.SyntaxKind.BarBarToken]: lua.SyntaxKind.OrOperator,
    [ts.SyntaxKind.PlusToken]: lua.SyntaxKind.AdditionOperator,
    [ts.SyntaxKind.MinusToken]: lua.SyntaxKind.SubtractionOperator,
    [ts.SyntaxKind.AsteriskToken]: lua.SyntaxKind.MultiplicationOperator,
    [ts.SyntaxKind.AsteriskAsteriskToken]: lua.SyntaxKind.PowerOperator,
    [ts.SyntaxKind.SlashToken]: lua.SyntaxKind.DivisionOperator,
    [ts.SyntaxKind.PercentToken]: lua.SyntaxKind.ModuloOperator,
    [ts.SyntaxKind.GreaterThanToken]: lua.SyntaxKind.GreaterThanOperator,
    [ts.SyntaxKind.GreaterThanEqualsToken]: lua.SyntaxKind.GreaterEqualOperator,
    [ts.SyntaxKind.LessThanToken]: lua.SyntaxKind.LessThanOperator,
    [ts.SyntaxKind.LessThanEqualsToken]: lua.SyntaxKind.LessEqualOperator,
    [ts.SyntaxKind.EqualsEqualsToken]: lua.SyntaxKind.EqualityOperator,
    [ts.SyntaxKind.EqualsEqualsEqualsToken]: lua.SyntaxKind.EqualityOperator,
    [ts.SyntaxKind.ExclamationEqualsToken]: lua.SyntaxKind.InequalityOperator,
    [ts.SyntaxKind.ExclamationEqualsEqualsToken]: lua.SyntaxKind.InequalityOperator,
};
function transformBinaryOperation(context, left, right, operator, node) {
    if (bit_1.isBitOperator(operator)) {
        return bit_1.transformBinaryBitOperation(context, node, left, right, operator);
    }
    if (operator === ts.SyntaxKind.QuestionQuestionToken) {
        utils_1.assert(ts.isBinaryExpression(node));
        return transformNullishCoalescingExpression(context, node);
    }
    let luaOperator = simpleOperatorsToLua[operator];
    // Check if we need to use string concat operator
    if (operator === ts.SyntaxKind.PlusToken && ts.isBinaryExpression(node)) {
        const typeLeft = context.checker.getTypeAtLocation(node.left);
        const typeRight = context.checker.getTypeAtLocation(node.right);
        if (typescript_1.isStringType(context, typeLeft) || typescript_1.isStringType(context, typeRight)) {
            left = lua_ast_1.wrapInToStringForConcat(left);
            right = lua_ast_1.wrapInToStringForConcat(right);
            luaOperator = lua.SyntaxKind.ConcatOperator;
        }
    }
    return lua.createBinaryExpression(left, right, luaOperator, node);
}
exports.transformBinaryOperation = transformBinaryOperation;
exports.transformBinaryExpression = (node, context) => {
    const operator = node.operatorToken.kind;
    const typeOfResult = typeof_1.transformTypeOfBinaryExpression(context, node);
    if (typeOfResult) {
        return typeOfResult;
    }
    if (compound_1.isCompoundAssignmentToken(operator)) {
        const token = compound_1.unwrapCompoundAssignmentToken(operator);
        return compound_1.transformCompoundAssignmentExpression(context, node, node.left, node.right, token, false);
    }
    switch (operator) {
        case ts.SyntaxKind.EqualsToken:
            return assignments_1.transformAssignmentExpression(context, node);
        case ts.SyntaxKind.InKeyword: {
            const lhs = context.transformExpression(node.left);
            const rhs = context.transformExpression(node.right);
            const indexExpression = lua.createTableIndexExpression(rhs, lhs);
            return lua.createBinaryExpression(indexExpression, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator, node);
        }
        case ts.SyntaxKind.InstanceOfKeyword: {
            const lhs = context.transformExpression(node.left);
            const rhs = context.transformExpression(node.right);
            const rhsType = context.checker.getTypeAtLocation(node.right);
            const annotations = annotations_1.getTypeAnnotations(rhsType);
            if (annotations.has(annotations_1.AnnotationKind.Extension) || annotations.has(annotations_1.AnnotationKind.MetaExtension)) {
                context.diagnostics.push(diagnostics_1.extensionInvalidInstanceOf(node));
            }
            if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
                context.diagnostics.push(diagnostics_1.luaTableInvalidInstanceOf(node));
            }
            if (typescript_1.isStandardLibraryType(context, rhsType, "ObjectConstructor")) {
                return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.InstanceOfObject, node, lhs);
            }
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.InstanceOf, node, lhs, rhs);
        }
        case ts.SyntaxKind.CommaToken: {
            return lua_ast_1.createImmediatelyInvokedFunctionExpression(context.transformStatements(ts.createExpressionStatement(node.left)), context.transformExpression(node.right), node);
        }
        default:
            return transformBinaryOperation(context, context.transformExpression(node.left), context.transformExpression(node.right), operator, node);
    }
};
function transformBinaryExpressionStatement(context, node) {
    const expression = node.expression;
    if (!ts.isBinaryExpression(expression))
        return;
    const operator = expression.operatorToken.kind;
    if (compound_1.isCompoundAssignmentToken(operator)) {
        // +=, -=, etc...
        const token = compound_1.unwrapCompoundAssignmentToken(operator);
        return compound_1.transformCompoundAssignmentStatement(context, expression, expression.left, expression.right, token);
    }
    else if (operator === ts.SyntaxKind.EqualsToken) {
        return assignments_1.transformAssignmentStatement(context, expression);
    }
    else if (operator === ts.SyntaxKind.CommaToken) {
        const statements = [
            ...context.transformStatements(ts.createExpressionStatement(expression.left)),
            ...context.transformStatements(ts.createExpressionStatement(expression.right)),
        ];
        return lua.createDoStatement(statements, expression);
    }
}
exports.transformBinaryExpressionStatement = transformBinaryExpressionStatement;
function transformNullishCoalescingExpression(context, node) {
    const lhsType = context.checker.getTypeAtLocation(node.left);
    // Check if we can take a shortcut to 'lhs or rhs' if the left-hand side cannot be 'false'.
    const typeCanBeFalse = (type) => (type.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.Boolean)) !== 0 ||
        (type.flags & ts.TypeFlags.BooleanLiteral & ts.TypeFlags.PossiblyFalsy) !== 0;
    if (typescript_1.typeCanSatisfy(context, lhsType, typeCanBeFalse)) {
        // lhs can be false, transform to IIFE
        const lhsIdentifier = lua.createIdentifier("____lhs");
        const nilComparison = lua.createBinaryExpression(lua.cloneIdentifier(lhsIdentifier), lua.createNilLiteral(), lua.SyntaxKind.EqualityOperator);
        // if ____ == nil then return rhs else return ____ end
        const ifStatement = lua.createIfStatement(nilComparison, lua.createBlock([lua.createReturnStatement([context.transformExpression(node.right)])]), lua.createBlock([lua.createReturnStatement([lua.cloneIdentifier(lhsIdentifier)])]));
        // (function(lhs') if lhs' == nil then return rhs else return lhs' end)(lhs)
        return lua.createCallExpression(lua.createFunctionExpression(lua.createBlock([ifStatement]), [lhsIdentifier]), [
            context.transformExpression(node.left),
        ]);
    }
    else {
        // lhs or rhs
        return lua.createBinaryExpression(context.transformExpression(node.left), context.transformExpression(node.right), lua.SyntaxKind.OrOperator, node);
    }
}
//# sourceMappingURL=index.js.map