"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformCompoundAssignmentStatement = exports.transformCompoundAssignmentExpression = exports.unwrapCompoundAssignmentToken = exports.isCompoundAssignmentToken = exports.parseAccessExpressionWithEvaluationEffects = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const lua_ast_1 = require("../../utils/lua-ast");
const typescript_1 = require("../../utils/typescript");
const binary_expression_1 = require("../binary-expression");
const assignments_1 = require("./assignments");
// If expression is property/element access with possible effects from being evaluated, returns separated object and index expressions.
function parseAccessExpressionWithEvaluationEffects(context, node) {
    if (ts.isElementAccessExpression(node) &&
        (typescript_1.isExpressionWithEvaluationEffect(node.expression) || typescript_1.isExpressionWithEvaluationEffect(node.argumentExpression))) {
        const type = context.checker.getTypeAtLocation(node.expression);
        if (typescript_1.isArrayType(context, type)) {
            // Offset arrays by one
            const oneLit = ts.createNumericLiteral("1");
            const exp = ts.createParen(node.argumentExpression);
            const addExp = ts.createBinary(exp, ts.SyntaxKind.PlusToken, oneLit);
            return [node.expression, addExp];
        }
        else {
            return [node.expression, node.argumentExpression];
        }
    }
    else if (ts.isPropertyAccessExpression(node) && typescript_1.isExpressionWithEvaluationEffect(node.expression)) {
        return [node.expression, ts.createStringLiteral(node.name.text)];
    }
    return [];
}
exports.parseAccessExpressionWithEvaluationEffects = parseAccessExpressionWithEvaluationEffects;
const compoundToAssignmentTokens = {
    [ts.SyntaxKind.BarEqualsToken]: ts.SyntaxKind.BarToken,
    [ts.SyntaxKind.PlusEqualsToken]: ts.SyntaxKind.PlusToken,
    [ts.SyntaxKind.CaretEqualsToken]: ts.SyntaxKind.CaretToken,
    [ts.SyntaxKind.MinusEqualsToken]: ts.SyntaxKind.MinusToken,
    [ts.SyntaxKind.SlashEqualsToken]: ts.SyntaxKind.SlashToken,
    [ts.SyntaxKind.PercentEqualsToken]: ts.SyntaxKind.PercentToken,
    [ts.SyntaxKind.AsteriskEqualsToken]: ts.SyntaxKind.AsteriskToken,
    [ts.SyntaxKind.AmpersandEqualsToken]: ts.SyntaxKind.AmpersandToken,
    [ts.SyntaxKind.AsteriskAsteriskEqualsToken]: ts.SyntaxKind.AsteriskAsteriskToken,
    [ts.SyntaxKind.LessThanLessThanEqualsToken]: ts.SyntaxKind.LessThanLessThanToken,
    [ts.SyntaxKind.GreaterThanGreaterThanEqualsToken]: ts.SyntaxKind.GreaterThanGreaterThanToken,
    [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
    [ts.SyntaxKind.BarBarEqualsToken]: ts.SyntaxKind.BarBarToken,
    [ts.SyntaxKind.AmpersandAmpersandEqualsToken]: ts.SyntaxKind.AmpersandAmpersandToken,
    [ts.SyntaxKind.QuestionQuestionEqualsToken]: ts.SyntaxKind.QuestionQuestionToken,
};
exports.isCompoundAssignmentToken = (token) => token in compoundToAssignmentTokens;
exports.unwrapCompoundAssignmentToken = (token) => compoundToAssignmentTokens[token];
function transformCompoundAssignmentExpression(context, expression, 
// TODO: Change type to ts.LeftHandSideExpression?
lhs, rhs, operator, isPostfix) {
    const left = utils_1.cast(context.transformExpression(lhs), lua.isAssignmentLeftHandSideExpression);
    const right = context.transformExpression(rhs);
    const [objExpression, indexExpression] = parseAccessExpressionWithEvaluationEffects(context, lhs);
    if (objExpression && indexExpression) {
        // Complex property/element accesses need to cache object/index expressions to avoid repeating side-effects
        // local __obj, __index = ${objExpression}, ${indexExpression};
        const obj = lua.createIdentifier("____obj");
        const index = lua.createIdentifier("____index");
        const objAndIndexDeclaration = lua.createVariableDeclarationStatement([obj, index], [context.transformExpression(objExpression), context.transformExpression(indexExpression)]);
        const accessExpression = lua.createTableIndexExpression(obj, index);
        const tmp = lua.createIdentifier("____tmp");
        let tmpDeclaration;
        let assignStatement;
        if (isPostfix) {
            // local ____tmp = ____obj[____index];
            // ____obj[____index] = ____tmp ${replacementOperator} ${right};
            tmpDeclaration = lua.createVariableDeclarationStatement(tmp, accessExpression);
            const operatorExpression = binary_expression_1.transformBinaryOperation(context, tmp, right, operator, expression);
            assignStatement = lua.createAssignmentStatement(accessExpression, operatorExpression);
        }
        else {
            // local ____tmp = ____obj[____index] ${replacementOperator} ${right};
            // ____obj[____index] = ____tmp;
            const operatorExpression = binary_expression_1.transformBinaryOperation(context, accessExpression, right, operator, expression);
            tmpDeclaration = lua.createVariableDeclarationStatement(tmp, operatorExpression);
            assignStatement = lua.createAssignmentStatement(accessExpression, tmp);
        }
        // return ____tmp
        return lua_ast_1.createImmediatelyInvokedFunctionExpression([objAndIndexDeclaration, tmpDeclaration, assignStatement], tmp, expression);
    }
    else if (isPostfix) {
        // Postfix expressions need to cache original value in temp
        // local ____tmp = ${left};
        // ${left} = ____tmp ${replacementOperator} ${right};
        // return ____tmp
        const tmpIdentifier = lua.createIdentifier("____tmp");
        const tmpDeclaration = lua.createVariableDeclarationStatement(tmpIdentifier, left);
        const operatorExpression = binary_expression_1.transformBinaryOperation(context, tmpIdentifier, right, operator, expression);
        const assignStatements = assignments_1.transformAssignment(context, lhs, operatorExpression);
        return lua_ast_1.createImmediatelyInvokedFunctionExpression([tmpDeclaration, ...assignStatements], tmpIdentifier, expression);
    }
    else if (ts.isPropertyAccessExpression(lhs) || ts.isElementAccessExpression(lhs)) {
        // Simple property/element access expressions need to cache in temp to avoid double-evaluation
        // local ____tmp = ${left} ${replacementOperator} ${right};
        // ${left} = ____tmp;
        // return ____tmp
        const tmpIdentifier = lua.createIdentifier("____tmp");
        const operatorExpression = binary_expression_1.transformBinaryOperation(context, left, right, operator, expression);
        const tmpDeclaration = lua.createVariableDeclarationStatement(tmpIdentifier, operatorExpression);
        const assignStatements = assignments_1.transformAssignment(context, lhs, tmpIdentifier);
        if (isSetterSkippingCompoundAssignmentOperator(operator)) {
            return lua_ast_1.createImmediatelyInvokedFunctionExpression([tmpDeclaration, ...transformSetterSkippingCompoundAssignment(context, tmpIdentifier, operator, rhs)], tmpIdentifier, expression);
        }
        return lua_ast_1.createImmediatelyInvokedFunctionExpression([tmpDeclaration, ...assignStatements], tmpIdentifier, expression);
    }
    else {
        // Simple expressions
        // ${left} = ${right}; return ${right}
        const operatorExpression = binary_expression_1.transformBinaryOperation(context, left, right, operator, expression);
        const assignStatements = assignments_1.transformAssignment(context, lhs, operatorExpression);
        return lua_ast_1.createImmediatelyInvokedFunctionExpression(assignStatements, left, expression);
    }
}
exports.transformCompoundAssignmentExpression = transformCompoundAssignmentExpression;
function transformCompoundAssignmentStatement(context, node, lhs, rhs, operator) {
    const left = utils_1.cast(context.transformExpression(lhs), lua.isAssignmentLeftHandSideExpression);
    const right = context.transformExpression(rhs);
    const [objExpression, indexExpression] = parseAccessExpressionWithEvaluationEffects(context, lhs);
    if (objExpression && indexExpression) {
        // Complex property/element accesses need to cache object/index expressions to avoid repeating side-effects
        // local __obj, __index = ${objExpression}, ${indexExpression};
        // ____obj[____index] = ____obj[____index] ${replacementOperator} ${right};
        const obj = lua.createIdentifier("____obj");
        const index = lua.createIdentifier("____index");
        const objAndIndexDeclaration = lua.createVariableDeclarationStatement([obj, index], [context.transformExpression(objExpression), context.transformExpression(indexExpression)]);
        const accessExpression = lua.createTableIndexExpression(obj, index);
        if (isSetterSkippingCompoundAssignmentOperator(operator)) {
            return [
                objAndIndexDeclaration,
                ...transformSetterSkippingCompoundAssignment(context, accessExpression, operator, rhs, node),
            ];
        }
        const operatorExpression = binary_expression_1.transformBinaryOperation(context, accessExpression, right, operator, node);
        const assignStatement = lua.createAssignmentStatement(accessExpression, operatorExpression);
        return [objAndIndexDeclaration, assignStatement];
    }
    else {
        if (isSetterSkippingCompoundAssignmentOperator(operator)) {
            const luaLhs = context.transformExpression(lhs);
            return transformSetterSkippingCompoundAssignment(context, luaLhs, operator, rhs, node);
        }
        // Simple statements
        // ${left} = ${left} ${replacementOperator} ${right}
        const operatorExpression = binary_expression_1.transformBinaryOperation(context, left, right, operator, node);
        return assignments_1.transformAssignment(context, lhs, operatorExpression);
    }
}
exports.transformCompoundAssignmentStatement = transformCompoundAssignmentStatement;
function isSetterSkippingCompoundAssignmentOperator(operator) {
    return (operator === ts.SyntaxKind.AmpersandAmpersandToken ||
        operator === ts.SyntaxKind.BarBarToken ||
        operator === ts.SyntaxKind.QuestionQuestionToken);
}
function transformSetterSkippingCompoundAssignment(context, lhs, operator, rhs, node) {
    // These assignments have the form 'if x then y = z', figure out what condition x is first.
    let condition;
    if (operator === ts.SyntaxKind.AmpersandAmpersandToken) {
        condition = lhs;
    }
    else if (operator === ts.SyntaxKind.BarBarToken) {
        condition = lua.createUnaryExpression(lhs, lua.SyntaxKind.NotOperator);
    }
    else if (operator === ts.SyntaxKind.QuestionQuestionToken) {
        condition = lua.createBinaryExpression(lhs, lua.createNilLiteral(), lua.SyntaxKind.EqualityOperator);
    }
    else {
        utils_1.assertNever(operator);
    }
    // if condition then lhs = rhs end
    return [
        lua.createIfStatement(condition, lua.createBlock([lua.createAssignmentStatement(lhs, context.transformExpression(rhs))]), undefined, node),
    ];
}
//# sourceMappingURL=compound.js.map