"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAssignmentPattern = exports.transformDestructuringAssignment = exports.isArrayLength = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const literal_1 = require("../literal");
const assignments_1 = require("./assignments");
function isArrayLength(context, expression) {
    if (!ts.isPropertyAccessExpression(expression) && !ts.isElementAccessExpression(expression)) {
        return false;
    }
    const type = context.checker.getTypeAtLocation(expression.expression);
    if (!typescript_1.isArrayType(context, type)) {
        return false;
    }
    const name = ts.isPropertyAccessExpression(expression)
        ? expression.name.text
        : ts.isStringLiteral(expression.argumentExpression)
            ? expression.argumentExpression.text
            : undefined;
    return name === "length";
}
exports.isArrayLength = isArrayLength;
function transformDestructuringAssignment(context, node, root) {
    return transformAssignmentPattern(context, node.left, root);
}
exports.transformDestructuringAssignment = transformDestructuringAssignment;
function transformAssignmentPattern(context, node, root) {
    switch (node.kind) {
        case ts.SyntaxKind.ObjectLiteralExpression:
            return transformObjectLiteralAssignmentPattern(context, node, root);
        case ts.SyntaxKind.ArrayLiteralExpression:
            return transformArrayLiteralAssignmentPattern(context, node, root);
    }
}
exports.transformAssignmentPattern = transformAssignmentPattern;
function transformArrayLiteralAssignmentPattern(context, node, root) {
    return node.elements.flatMap((element, index) => {
        const indexedRoot = lua.createTableIndexExpression(root, lua.createNumericLiteral(index + 1), element);
        switch (element.kind) {
            case ts.SyntaxKind.ObjectLiteralExpression:
                return transformObjectLiteralAssignmentPattern(context, element, indexedRoot);
            case ts.SyntaxKind.ArrayLiteralExpression:
                return transformArrayLiteralAssignmentPattern(context, element, indexedRoot);
            case ts.SyntaxKind.BinaryExpression:
                const assignedVariable = lua.createIdentifier("____bindingAssignmentValue");
                const assignedVariableDeclaration = lua.createVariableDeclarationStatement(assignedVariable, indexedRoot);
                const nilCondition = lua.createBinaryExpression(assignedVariable, lua.createNilLiteral(), lua.SyntaxKind.EqualityOperator);
                const defaultAssignmentStatements = assignments_1.transformAssignment(context, element.left, context.transformExpression(element.right));
                const elseAssignmentStatements = assignments_1.transformAssignment(context, element.left, assignedVariable);
                const ifBlock = lua.createBlock(defaultAssignmentStatements);
                const elseBlock = lua.createBlock(elseAssignmentStatements);
                const ifStatement = lua.createIfStatement(nilCondition, ifBlock, elseBlock, node);
                return [assignedVariableDeclaration, ifStatement];
            case ts.SyntaxKind.Identifier:
            case ts.SyntaxKind.PropertyAccessExpression:
            case ts.SyntaxKind.ElementAccessExpression:
                return assignments_1.transformAssignment(context, element, indexedRoot);
            case ts.SyntaxKind.SpreadElement:
                if (index !== node.elements.length - 1) {
                    // TypeScript error
                    return [];
                }
                const restElements = lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArraySlice, undefined, root, lua.createNumericLiteral(index));
                return assignments_1.transformAssignment(context, element.expression, restElements);
            case ts.SyntaxKind.OmittedExpression:
                return [];
            default:
                // TypeScript error
                return [];
        }
    });
}
function transformObjectLiteralAssignmentPattern(context, node, root) {
    const result = [];
    for (const property of node.properties) {
        switch (property.kind) {
            case ts.SyntaxKind.ShorthandPropertyAssignment:
                result.push(...transformShorthandPropertyAssignment(context, property, root));
                break;
            case ts.SyntaxKind.PropertyAssignment:
                result.push(...transformPropertyAssignment(context, property, root));
                break;
            case ts.SyntaxKind.SpreadAssignment:
                result.push(...transformSpreadAssignment(context, property, root, node.properties));
                break;
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.SetAccessor:
                // TypeScript error
                break;
            default:
                utils_1.assertNever(property);
        }
    }
    return result;
}
function transformShorthandPropertyAssignment(context, node, root) {
    const result = [];
    const assignmentVariableName = assignments_1.transformAssignmentLeftHandSideExpression(context, node.name);
    const extractionIndex = lua.createStringLiteral(node.name.text);
    const variableExtractionAssignmentStatements = assignments_1.transformAssignment(context, node.name, lua.createTableIndexExpression(root, extractionIndex));
    result.push(...variableExtractionAssignmentStatements);
    const defaultInitializer = node.objectAssignmentInitializer
        ? context.transformExpression(node.objectAssignmentInitializer)
        : undefined;
    if (defaultInitializer) {
        const nilCondition = lua.createBinaryExpression(assignmentVariableName, lua.createNilLiteral(), lua.SyntaxKind.EqualityOperator);
        const assignmentStatements = assignments_1.transformAssignment(context, node.name, defaultInitializer);
        const ifBlock = lua.createBlock(assignmentStatements);
        result.push(lua.createIfStatement(nilCondition, ifBlock, undefined, node));
    }
    return result;
}
function transformPropertyAssignment(context, node, root) {
    const result = [];
    if (typescript_1.isAssignmentPattern(node.initializer)) {
        const propertyAccessString = literal_1.transformPropertyName(context, node.name);
        const newRootAccess = lua.createTableIndexExpression(root, propertyAccessString);
        if (ts.isObjectLiteralExpression(node.initializer)) {
            return transformObjectLiteralAssignmentPattern(context, node.initializer, newRootAccess);
        }
        if (ts.isArrayLiteralExpression(node.initializer)) {
            return transformArrayLiteralAssignmentPattern(context, node.initializer, newRootAccess);
        }
    }
    const leftExpression = ts.isBinaryExpression(node.initializer) ? node.initializer.left : node.initializer;
    const variableToExtract = literal_1.transformPropertyName(context, node.name);
    const extractingExpression = lua.createTableIndexExpression(root, variableToExtract);
    const destructureAssignmentStatements = assignments_1.transformAssignment(context, leftExpression, extractingExpression);
    result.push(...destructureAssignmentStatements);
    if (ts.isBinaryExpression(node.initializer)) {
        const assignmentLeftHandSide = context.transformExpression(node.initializer.left);
        const nilCondition = lua.createBinaryExpression(assignmentLeftHandSide, lua.createNilLiteral(), lua.SyntaxKind.EqualityOperator);
        const ifBlock = lua.createBlock(assignments_1.transformAssignmentStatement(context, node.initializer));
        result.push(lua.createIfStatement(nilCondition, ifBlock, undefined, node));
    }
    return result;
}
function transformSpreadAssignment(context, node, root, properties) {
    const usedProperties = [];
    for (const property of properties) {
        if ((ts.isShorthandPropertyAssignment(property) || ts.isPropertyAssignment(property)) &&
            !ts.isComputedPropertyName(property.name) &&
            !ts.isPrivateIdentifier(property.name)) {
            const name = ts.isIdentifier(property.name)
                ? lua.createStringLiteral(property.name.text)
                : context.transformExpression(property.name);
            usedProperties.push(lua.createTableFieldExpression(lua.createBooleanLiteral(true), name));
        }
    }
    const extractingExpression = lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ObjectRest, undefined, root, lua.createTableExpression(usedProperties));
    return assignments_1.transformAssignment(context, node.expression, extractingExpression);
}
//# sourceMappingURL=destructuring-assignments.js.map