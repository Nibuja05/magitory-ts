"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAssignmentStatement = exports.transformAssignmentExpression = exports.transformAssignment = exports.transformAssignmentLeftHandSideExpression = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const annotations_1 = require("../../utils/annotations");
const assignment_validation_1 = require("../../utils/assignment-validation");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const access_1 = require("../access");
const lua_table_1 = require("../lua-table");
const destructuring_assignments_1 = require("./destructuring-assignments");
function transformAssignmentLeftHandSideExpression(context, node) {
    var _a;
    const symbol = context.checker.getSymbolAtLocation(node);
    const left = ts.isPropertyAccessExpression(node)
        ? (_a = lua_table_1.transformLuaTablePropertyAccessInAssignment(context, node)) !== null && _a !== void 0 ? _a : context.transformExpression(node) : context.transformExpression(node);
    return lua.isIdentifier(left) && symbol && export_1.isSymbolExported(context, symbol)
        ? export_1.createExportedIdentifier(context, left)
        : utils_1.cast(left, lua.isAssignmentLeftHandSideExpression);
}
exports.transformAssignmentLeftHandSideExpression = transformAssignmentLeftHandSideExpression;
function transformAssignment(context, 
// TODO: Change type to ts.LeftHandSideExpression?
lhs, right, parent) {
    if (destructuring_assignments_1.isArrayLength(context, lhs)) {
        const arrayLengthAssignment = lua.createExpressionStatement(lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArraySetLength, parent, context.transformExpression(lhs.expression), right));
        return [arrayLengthAssignment];
    }
    const symbol = ts.isShorthandPropertyAssignment(lhs.parent)
        ? context.checker.getShorthandAssignmentValueSymbol(lhs.parent)
        : context.checker.getSymbolAtLocation(lhs);
    const dependentSymbols = symbol ? export_1.getDependenciesOfSymbol(context, symbol) : [];
    const left = transformAssignmentLeftHandSideExpression(context, lhs);
    const rootAssignment = lua.createAssignmentStatement(left, right, lhs.parent);
    return [
        rootAssignment,
        ...dependentSymbols.map(symbol => {
            const [left] = rootAssignment.left;
            const identifierToAssign = export_1.createExportedIdentifier(context, lua.createIdentifier(symbol.name));
            return lua.createAssignmentStatement(identifierToAssign, left);
        }),
    ];
}
exports.transformAssignment = transformAssignment;
function transformAssignmentExpression(context, expression) {
    // Validate assignment
    const rightType = context.checker.getTypeAtLocation(expression.right);
    const leftType = context.checker.getTypeAtLocation(expression.left);
    assignment_validation_1.validateAssignment(context, expression.right, rightType, leftType);
    if (destructuring_assignments_1.isArrayLength(context, expression.left)) {
        // array.length = x
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArraySetLength, expression, context.transformExpression(expression.left.expression), context.transformExpression(expression.right));
    }
    if (typescript_1.isDestructuringAssignment(expression)) {
        const rootIdentifier = lua.createAnonymousIdentifier(expression.left);
        let right = context.transformExpression(expression.right);
        if (annotations_1.isTupleReturnCall(context, expression.right)) {
            right = lua_ast_1.wrapInTable(right);
        }
        const statements = [
            lua.createVariableDeclarationStatement(rootIdentifier, right),
            ...destructuring_assignments_1.transformDestructuringAssignment(context, expression, rootIdentifier),
        ];
        return lua_ast_1.createImmediatelyInvokedFunctionExpression(statements, rootIdentifier, expression);
    }
    if (ts.isPropertyAccessExpression(expression.left) || ts.isElementAccessExpression(expression.left)) {
        // Left is property/element access: cache result while maintaining order of evaluation
        // (function(o, i, v) o[i] = v; return v end)(${objExpression}, ${indexExpression}, ${right})
        const objParameter = lua.createIdentifier("o");
        const indexParameter = lua.createIdentifier("i");
        const valueParameter = lua.createIdentifier("v");
        const indexStatement = lua.createTableIndexExpression(objParameter, indexParameter);
        const statements = [
            lua.createAssignmentStatement(indexStatement, valueParameter),
            lua.createReturnStatement([valueParameter]),
        ];
        const iife = lua.createFunctionExpression(lua.createBlock(statements), [
            objParameter,
            indexParameter,
            valueParameter,
        ]);
        const objExpression = context.transformExpression(expression.left.expression);
        let indexExpression;
        if (ts.isPropertyAccessExpression(expression.left)) {
            // Called only for validation
            lua_table_1.transformLuaTablePropertyAccessInAssignment(context, expression.left);
            // Property access
            indexExpression = lua.createStringLiteral(expression.left.name.text);
        }
        else {
            // Element access
            indexExpression = access_1.transformElementAccessArgument(context, expression.left);
        }
        const args = [objExpression, indexExpression, context.transformExpression(expression.right)];
        return lua.createCallExpression(iife, args, expression);
    }
    else {
        // Simple assignment
        // (function() ${left} = ${right}; return ${left} end)()
        const left = context.transformExpression(expression.left);
        const right = context.transformExpression(expression.right);
        return lua_ast_1.createImmediatelyInvokedFunctionExpression(transformAssignment(context, expression.left, right), left, expression);
    }
}
exports.transformAssignmentExpression = transformAssignmentExpression;
const canBeTransformedToLuaAssignmentStatement = (context, node) => ts.isArrayLiteralExpression(node.left) &&
    node.left.elements.every(element => {
        if (destructuring_assignments_1.isArrayLength(context, element)) {
            return false;
        }
        if (ts.isPropertyAccessExpression(element) || ts.isElementAccessExpression(element)) {
            return true;
        }
        if (ts.isIdentifier(element)) {
            const symbol = context.checker.getSymbolAtLocation(element);
            if (symbol) {
                const aliases = export_1.getDependenciesOfSymbol(context, symbol);
                return aliases.length === 0;
            }
        }
    });
function transformAssignmentStatement(context, expression) {
    // Validate assignment
    const rightType = context.checker.getTypeAtLocation(expression.right);
    const leftType = context.checker.getTypeAtLocation(expression.left);
    assignment_validation_1.validateAssignment(context, expression.right, rightType, leftType);
    if (typescript_1.isDestructuringAssignment(expression)) {
        if (canBeTransformedToLuaAssignmentStatement(context, expression)) {
            const rightType = context.checker.getTypeAtLocation(expression.right);
            let right = context.transformExpression(expression.right);
            if (!annotations_1.isTupleReturnCall(context, expression.right) && typescript_1.isArrayType(context, rightType)) {
                right = lua_ast_1.createUnpackCall(context, right, expression.right);
            }
            const left = expression.left.elements.map(e => transformAssignmentLeftHandSideExpression(context, e));
            return [lua.createAssignmentStatement(left, right, expression)];
        }
        let right = context.transformExpression(expression.right);
        if (annotations_1.isTupleReturnCall(context, expression.right)) {
            right = lua_ast_1.wrapInTable(right);
        }
        const rootIdentifier = lua.createAnonymousIdentifier(expression.left);
        return [
            lua.createVariableDeclarationStatement(rootIdentifier, right),
            ...destructuring_assignments_1.transformDestructuringAssignment(context, expression, rootIdentifier),
        ];
    }
    else {
        return transformAssignment(context, expression.left, context.transformExpression(expression.right));
    }
}
exports.transformAssignmentStatement = transformAssignmentStatement;
//# sourceMappingURL=assignments.js.map