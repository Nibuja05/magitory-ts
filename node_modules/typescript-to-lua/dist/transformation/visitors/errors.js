"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformThrowStatement = exports.transformTryStatement = void 0;
const lua = require("../../LuaAST");
const annotations_1 = require("../utils/annotations");
const lua_ast_1 = require("../utils/lua-ast");
const scope_1 = require("../utils/scope");
const block_1 = require("./block");
const identifier_1 = require("./identifier");
exports.transformTryStatement = (statement, context) => {
    const [tryBlock, tryScope] = block_1.transformScopeBlock(context, statement.tryBlock, scope_1.ScopeType.Try);
    const tryResultIdentifier = lua.createIdentifier("____try");
    const returnValueIdentifier = lua.createIdentifier("____returnValue");
    const result = [];
    let returnedIdentifier;
    let returnCondition;
    const pCall = lua.createIdentifier("pcall");
    const tryCall = lua.createCallExpression(pCall, [lua.createFunctionExpression(tryBlock)]);
    if (statement.catchClause && statement.catchClause.block.statements.length > 0) {
        // try with catch
        let [catchBlock, catchScope] = block_1.transformScopeBlock(context, statement.catchClause.block, scope_1.ScopeType.Catch);
        if (statement.catchClause.variableDeclaration) {
            // Replace ____returned with catch variable
            returnedIdentifier = identifier_1.transformIdentifier(context, statement.catchClause.variableDeclaration.name);
        }
        else if (tryScope.functionReturned || catchScope.functionReturned) {
            returnedIdentifier = lua.createIdentifier("____returned");
        }
        const tryReturnIdentifiers = [tryResultIdentifier]; // ____try
        if (returnedIdentifier) {
            tryReturnIdentifiers.push(returnedIdentifier); // ____returned or catch variable
            if (tryScope.functionReturned || catchScope.functionReturned) {
                tryReturnIdentifiers.push(returnValueIdentifier); // ____returnValue
                returnCondition = lua.cloneIdentifier(returnedIdentifier);
            }
        }
        result.push(lua.createVariableDeclarationStatement(tryReturnIdentifiers, tryCall));
        if ((tryScope.functionReturned || catchScope.functionReturned) && returnedIdentifier) {
            // Wrap catch in function if try or catch has return
            const catchCall = lua.createCallExpression(lua.createFunctionExpression(catchBlock), []);
            const catchAssign = lua.createAssignmentStatement([lua.cloneIdentifier(returnedIdentifier), lua.cloneIdentifier(returnValueIdentifier)], catchCall);
            catchBlock = lua.createBlock([catchAssign]);
        }
        const notTryCondition = lua.createUnaryExpression(tryResultIdentifier, lua.SyntaxKind.NotOperator);
        result.push(lua.createIfStatement(notTryCondition, catchBlock));
    }
    else if (tryScope.functionReturned) {
        // try with return, but no catch
        returnedIdentifier = lua.createIdentifier("____returned");
        const returnedVariables = [tryResultIdentifier, returnedIdentifier, returnValueIdentifier];
        result.push(lua.createVariableDeclarationStatement(returnedVariables, tryCall));
        // change return condition from '____returned' to '____try and ____returned'
        returnCondition = lua.createBinaryExpression(lua.cloneIdentifier(tryResultIdentifier), returnedIdentifier, lua.SyntaxKind.AndOperator);
    }
    else {
        // try without return or catch
        result.push(lua.createExpressionStatement(tryCall));
    }
    if (statement.finallyBlock && statement.finallyBlock.statements.length > 0) {
        result.push(...context.transformStatements(statement.finallyBlock));
    }
    if (returnCondition && returnedIdentifier) {
        // With catch clause:
        //     if ____returned then return ____returnValue end
        // No catch clause:
        //     if ____try and ____returned then return ____returnValue end
        const returnValues = [];
        const parentTryCatch = scope_1.findScope(context, scope_1.ScopeType.Function | scope_1.ScopeType.Try | scope_1.ScopeType.Catch);
        if (parentTryCatch && parentTryCatch.type !== scope_1.ScopeType.Function) {
            // Nested try/catch needs to prefix a 'true' return value
            returnValues.push(lua.createBooleanLiteral(true));
        }
        if (annotations_1.isInTupleReturnFunction(context, statement)) {
            returnValues.push(lua_ast_1.createUnpackCall(context, lua.cloneIdentifier(returnValueIdentifier)));
        }
        else {
            returnValues.push(lua.cloneIdentifier(returnValueIdentifier));
        }
        const returnStatement = lua.createReturnStatement(returnValues);
        const ifReturnedStatement = lua.createIfStatement(returnCondition, lua.createBlock([returnStatement]));
        result.push(ifReturnedStatement);
    }
    return lua.createDoStatement(result, statement);
};
exports.transformThrowStatement = (statement, context) => {
    const parameters = [];
    if (statement.expression) {
        parameters.push(context.transformExpression(statement.expression));
        parameters.push(lua.createNumericLiteral(0));
    }
    return lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("error"), parameters), statement);
};
//# sourceMappingURL=errors.js.map