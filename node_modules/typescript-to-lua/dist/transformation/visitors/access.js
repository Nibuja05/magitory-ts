"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformQualifiedName = exports.transformPropertyAccessExpression = exports.transformElementAccessExpression = exports.transformElementAccessArgument = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const diagnostics_1 = require("../utils/diagnostics");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const typescript_1 = require("../utils/typescript");
const enum_1 = require("./enum");
const multi_1 = require("./language-extensions/multi");
const lua_table_1 = require("./lua-table");
function transformElementAccessArgument(context, node) {
    const index = context.transformExpression(node.argumentExpression);
    const type = context.checker.getTypeAtLocation(node.expression);
    const argumentType = context.checker.getTypeAtLocation(node.argumentExpression);
    if (typescript_1.isArrayType(context, type) && typescript_1.isNumberType(context, argumentType)) {
        return lua_ast_1.addToNumericExpression(index, 1);
    }
    return index;
}
exports.transformElementAccessArgument = transformElementAccessArgument;
exports.transformElementAccessExpression = (node, context) => {
    lua_table_1.validateLuaTableElementAccessExpression(context, node);
    const constEnumValue = enum_1.tryGetConstEnumValue(context, node);
    if (constEnumValue) {
        return constEnumValue;
    }
    const table = context.transformExpression(node.expression);
    const type = context.checker.getTypeAtLocation(node.expression);
    const argumentType = context.checker.getTypeAtLocation(node.argumentExpression);
    if (typescript_1.isStringType(context, type) && typescript_1.isNumberType(context, argumentType)) {
        const index = context.transformExpression(node.argumentExpression);
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.StringAccess, node, table, index);
    }
    const accessExpression = transformElementAccessArgument(context, node);
    if (ts.isCallExpression(node.expression) && multi_1.returnsMultiType(context, node.expression)) {
        const accessType = context.checker.getTypeAtLocation(node.argumentExpression);
        if (!typescript_1.isNumberType(context, accessType)) {
            context.diagnostics.push(diagnostics_1.invalidMultiReturnAccess(node));
        }
        const selectIdentifier = lua.createIdentifier("select");
        const selectCall = lua.createCallExpression(selectIdentifier, [accessExpression, table]);
        return selectCall;
    }
    return lua.createTableIndexExpression(table, accessExpression, node);
};
exports.transformPropertyAccessExpression = (expression, context) => {
    const constEnumValue = enum_1.tryGetConstEnumValue(context, expression);
    if (constEnumValue) {
        return constEnumValue;
    }
    const luaTableResult = lua_table_1.transformLuaTablePropertyAccessExpression(context, expression);
    if (luaTableResult) {
        return luaTableResult;
    }
    const builtinResult = builtins_1.transformBuiltinPropertyAccessExpression(context, expression);
    if (builtinResult) {
        return builtinResult;
    }
    if (ts.isCallExpression(expression.expression) && multi_1.returnsMultiType(context, expression.expression)) {
        context.diagnostics.push(diagnostics_1.invalidMultiReturnAccess(expression));
    }
    const property = expression.name.text;
    const type = context.checker.getTypeAtLocation(expression.expression);
    const annotations = annotations_1.getTypeAnnotations(type);
    // Do not output path for member only enums
    if (annotations.has(annotations_1.AnnotationKind.CompileMembersOnly)) {
        if (ts.isPropertyAccessExpression(expression.expression)) {
            // in case of ...x.enum.y transform to ...x.y
            return lua.createTableIndexExpression(context.transformExpression(expression.expression.expression), lua.createStringLiteral(property), expression);
        }
        else {
            return lua.createIdentifier(property, expression);
        }
    }
    const callPath = context.transformExpression(expression.expression);
    return lua.createTableIndexExpression(callPath, lua.createStringLiteral(property), expression);
};
exports.transformQualifiedName = (node, context) => {
    const right = lua.createStringLiteral(node.right.text, node.right);
    const left = context.transformExpression(node.left);
    return lua.createTableIndexExpression(left, right, node);
};
//# sourceMappingURL=access.js.map