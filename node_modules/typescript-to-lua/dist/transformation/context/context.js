"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformationContext = void 0;
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
const lua = require("../../LuaAST");
const utils_1 = require("../../utils");
const diagnostics_1 = require("../utils/diagnostics");
const lua_ast_1 = require("../utils/lua-ast");
class TransformationContext {
    constructor(program, sourceFile, visitorMap) {
        var _a, _b, _c;
        this.program = program;
        this.sourceFile = sourceFile;
        this.visitorMap = visitorMap;
        this.diagnostics = [];
        this.checker = this
            .program.getDiagnosticsProducingTypeChecker();
        this.options = this.program.getCompilerOptions();
        this.luaTarget = (_a = this.options.luaTarget) !== null && _a !== void 0 ? _a : CompilerOptions_1.LuaTarget.Universal;
        this.isModule = ts.isExternalModule(this.sourceFile);
        this.isStrict = ((_b = this.options.alwaysStrict) !== null && _b !== void 0 ? _b : this.options.strict) ||
            (this.isModule && this.options.target !== undefined && this.options.target >= ts.ScriptTarget.ES2015);
        this.currentNodeVisitors = [];
        // Use `getParseTreeNode` to get original SourceFile node, before it was substituted by custom transformers.
        // It's required because otherwise `getEmitResolver` won't use cached diagnostics, produced in `emitWorker`
        // and would try to re-analyze the file, which would fail because of replaced nodes.
        const originalSourceFile = (_c = ts.getParseTreeNode(sourceFile, ts.isSourceFile)) !== null && _c !== void 0 ? _c : sourceFile;
        this.resolver = this.checker.getEmitResolver(originalSourceFile);
    }
    transformNode(node, isExpression) {
        var _a;
        // TODO: Move to visitors?
        if ((_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.some(modifier => modifier.kind === ts.SyntaxKind.DeclareKeyword)) {
            return [];
        }
        const nodeVisitors = this.visitorMap.get(node.kind);
        if (!nodeVisitors || nodeVisitors.length === 0) {
            this.diagnostics.push(diagnostics_1.unsupportedNodeKind(node, node.kind));
            return isExpression ? [lua.createNilLiteral()] : [];
        }
        const previousNodeVisitors = this.currentNodeVisitors;
        this.currentNodeVisitors = [...nodeVisitors];
        const visitor = this.currentNodeVisitors.pop();
        const result = lua_ast_1.unwrapVisitorResult(visitor.transform(node, this));
        this.currentNodeVisitors = previousNodeVisitors;
        return result;
    }
    superTransformNode(node) {
        if (this.currentNodeVisitors.length === 0) {
            throw new Error(`There is no super transform for ${ts.SyntaxKind[node.kind]} visitor`);
        }
        const visitor = this.currentNodeVisitors.pop();
        return lua_ast_1.unwrapVisitorResult(visitor.transform(node, this));
    }
    transformExpression(node) {
        const [result] = this.transformNode(node, true);
        if (result === undefined) {
            throw new Error(`Expression visitor for node type ${ts.SyntaxKind[node.kind]} did not return any result.`);
        }
        return result;
    }
    superTransformExpression(node) {
        const [result] = this.superTransformNode(node);
        if (result === undefined) {
            throw new Error(`Expression visitor for node type ${ts.SyntaxKind[node.kind]} did not return any result.`);
        }
        return result;
    }
    transformStatements(node) {
        return utils_1.castArray(node).flatMap(n => this.transformNode(n));
    }
    superTransformStatements(node) {
        return utils_1.castArray(node).flatMap(n => this.superTransformNode(n));
    }
}
exports.TransformationContext = TransformationContext;
//# sourceMappingURL=context.js.map