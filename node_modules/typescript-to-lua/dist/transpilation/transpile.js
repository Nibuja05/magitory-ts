"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProgramTranspileResult = void 0;
const path = require("path");
const ts = require("typescript");
const CompilerOptions_1 = require("../CompilerOptions");
const LuaPrinter_1 = require("../LuaPrinter");
const transformation_1 = require("../transformation");
const utils_1 = require("../utils");
const plugins_1 = require("./plugins");
const transformers_1 = require("./transformers");
function getProgramTranspileResult(emitHost, writeFileResult, { program, sourceFiles: targetSourceFiles, customTransformers = {}, plugins: customPlugins = [] }) {
    const options = program.getCompilerOptions();
    const diagnostics = CompilerOptions_1.validateOptions(options);
    let transpiledFiles = [];
    if (options.noEmitOnError) {
        const preEmitDiagnostics = [
            ...diagnostics,
            ...program.getOptionsDiagnostics(),
            ...program.getGlobalDiagnostics(),
        ];
        if (targetSourceFiles) {
            for (const sourceFile of targetSourceFiles) {
                preEmitDiagnostics.push(...program.getSyntacticDiagnostics(sourceFile));
                preEmitDiagnostics.push(...program.getSemanticDiagnostics(sourceFile));
            }
        }
        else {
            preEmitDiagnostics.push(...program.getSyntacticDiagnostics());
            preEmitDiagnostics.push(...program.getSemanticDiagnostics());
        }
        if (preEmitDiagnostics.length === 0 && (options.declaration || options.composite)) {
            preEmitDiagnostics.push(...program.getDeclarationDiagnostics());
        }
        if (preEmitDiagnostics.length > 0) {
            return { diagnostics: preEmitDiagnostics, transpiledFiles };
        }
    }
    const plugins = plugins_1.getPlugins(program, diagnostics, customPlugins);
    const visitorMap = transformation_1.createVisitorMap(plugins.map(p => p.visitors).filter(utils_1.isNonNull));
    const printer = LuaPrinter_1.createPrinter(plugins.map(p => p.printer).filter(utils_1.isNonNull));
    const processSourceFile = (sourceFile) => {
        const { file, diagnostics: transformDiagnostics } = transformation_1.transformSourceFile(program, sourceFile, visitorMap);
        diagnostics.push(...transformDiagnostics);
        if (!options.noEmit && !options.emitDeclarationOnly) {
            const printResult = printer(program, emitHost, sourceFile.fileName, file);
            const sourceRootDir = program.getCommonSourceDirectory();
            const fileName = path.resolve(sourceRootDir, sourceFile.fileName);
            transpiledFiles.push({ sourceFiles: [sourceFile], fileName, luaAst: file, ...printResult });
        }
    };
    const transformers = transformers_1.getTransformers(program, diagnostics, customTransformers, processSourceFile);
    const isEmittableJsonFile = (sourceFile) => sourceFile.flags & ts.NodeFlags.JsonFile &&
        !options.emitDeclarationOnly &&
        !program.isSourceFileFromExternalLibrary(sourceFile);
    // We always have to run transformers to get diagnostics
    const oldNoEmit = options.noEmit;
    options.noEmit = false;
    const writeFile = (fileName, ...rest) => {
        if (!fileName.endsWith(".js") && !fileName.endsWith(".js.map")) {
            writeFileResult(fileName, ...rest);
        }
    };
    if (targetSourceFiles) {
        for (const file of targetSourceFiles) {
            if (isEmittableJsonFile(file)) {
                processSourceFile(file);
            }
            else {
                diagnostics.push(...program.emit(file, writeFile, undefined, false, transformers).diagnostics);
            }
        }
    }
    else {
        diagnostics.push(...program.emit(undefined, writeFile, undefined, false, transformers).diagnostics);
        // JSON files don't get through transformers and aren't written when outDir is the same as rootDir
        program.getSourceFiles().filter(isEmittableJsonFile).forEach(processSourceFile);
    }
    options.noEmit = oldNoEmit;
    if (options.noEmit || (options.noEmitOnError && diagnostics.length > 0)) {
        transpiledFiles = [];
    }
    return { diagnostics, transpiledFiles };
}
exports.getProgramTranspileResult = getProgramTranspileResult;
//# sourceMappingURL=transpile.js.map